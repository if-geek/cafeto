{"config":{"lang":["en","es"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cafeto","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Cafeto is a lightweight yet powerful framework designed as a top layer over Starlette, focusing on simplifying and accelerating the development of modern APIs. It harnesses the robust foundation of Starlette, offering additional tools for more efficient and organized development.</p> <p> English |  Espa\u00f1ol</p>"},{"location":"#requirements","title":"Requirements","text":"<p>This project requires Python 3.10 or a later version.</p>"},{"location":"#installation","title":"Installation","text":"Bash<pre><code>pip install cafeto\n</code></pre>"},{"location":"#project","title":"Project","text":"<p>Cafeto</p>"},{"location":"#docs","title":"Docs","text":"<p>Cafeto docs</p>"},{"location":"#description","title":"Description","text":"<p>Cafeto is a framework designed to create APIs efficiently and in an organized manner, drawing inspiration from other frameworks while incorporating innovative ideas.</p> <ul> <li>It offers a robust dependency injection system, supporting three lifecycle types: <code>Singleton</code>, <code>Scoped</code>, and <code>Transient</code>.</li> <li>Facilitates the handling of incoming and outgoing data through DTOs (Data Transfer Objects), which also play a key role in validating and managing server interactions.</li> <li>Includes an event system that extends the framework's capabilities, enabling greater customization and flexibility.</li> <li>Integrates seamlessly with tools like OpenAPI and Swagger to provide interactive documentation and API testing.</li> </ul> <p>With Cafeto, developers can build scalable and reliable APIs effortlessly, leveraging modern features and a well-structured approach.</p>"},{"location":"#starlette","title":"Starlette","text":"<p>Starlette, the backbone of Cafeto, is widely recognized as one of the most outstanding frameworks for building asynchronous web applications in Python. Its minimalist design, coupled with exceptional performance, makes it ideal for developers seeking flexibility and power. Starlette not only provides routing, middleware, and WebSocket support but also integrates advanced tools for asynchronous task management and testing, establishing itself as a gold standard in modern web development.</p> <p>Building on Starlette\u2019s power, Cafeto takes the experience to the next level, delivering an even more streamlined and developer-friendly solution for API creation. Together, Cafeto and Starlette form the perfect duo for any developer seeking speed, simplicity, and technical excellence.</p>"},{"location":"#main-objective","title":"Main Objective","text":"<p>To create a smoother development experience for APIs, providing intuitive abstractions, smart default configurations, and compatibility with modern standards.</p>"},{"location":"#example","title":"Example","text":"Python<pre><code>import uvicorn\n\nfrom cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\nfrom cafeto.models import BaseModel\n\n\napp: App = App()\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str\n\n\nclass CreateUserResponseDto(BaseModel):\n    id: int\n    username: str\n\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, data: CreateUserRequestDto) -&gt; CreateUserResponseDto:\n        user = {'id': 1, 'username': data.username}\n        return Ok(CreateUserResponseDto(**user))\n\napp.map_controllers()\n\nif __name__ == \"__main__\":\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000, reload=True)\n</code></pre> <ol> <li>It can also be run by command: Bash<pre><code>uvicorn main:app --host 0.0.0.0 --port 8000 --reload\n</code></pre></li> </ol> <p>This example shows how to define a controller and two DTOs (one for the request and one for the response), and how to set up a route to create a user.</p> <p>The <code>App</code> class inherits from the <code>Starlette</code> class, which means that the properties of Starlette are also available in the App class. An example of these properties is <code>Middleware</code>. However, there is an additional configuration called <code>CafetoConfig</code>, which will be explained later.</p> Python<pre><code>from cafeto.middleware import CORSMiddleware\n\nmiddleware = [\n    Middleware(CORSMiddleware, allow_origins=['*'])\n]\n\napp: App = App(debug=True, middleware=middleware)\n</code></pre>"},{"location":"#conclusion","title":"Conclusion","text":"<p>Cafeto is a powerful tool that facilitates the creation of APIs in Python. With support for dependency injection, DTOs, and automatic documentation, it is an excellent choice for developers looking for a simple yet professional solution for their API projects.</p>"},{"location":"access_control/","title":"Access Control","text":""},{"location":"access_control/#introduction","title":"Introduction","text":"<p>Access control to an API is crucial to ensure that only authorized users can interact with the system's resources and data. Cafeto uses the same type of decorator as Starlette. This allows specifying which users have permission to execute certain functions, protecting the API from unauthorized access and ensuring the security and privacy of the information.</p>"},{"location":"access_control/#usage","title":"Usage","text":"Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\napp: App = App()\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/view')\n    @app.requires(['admin'])\n    async def view(self) -&gt; str:\n        return Ok('Hello World!')\n</code></pre> <p><code>@app.requires</code> works in the same way as <code>@requires</code> in Starlette.</p>"},{"location":"api/","title":"API","text":"<p>Coming Soon </p>"},{"location":"controllers_and_actions/","title":"Controllers and Actions","text":""},{"location":"controllers_and_actions/#introduction","title":"Introduction","text":"<p>Controllers in a web application are responsible for handling user requests, processing data, and returning appropriate responses. They act as intermediaries between the model and the view.</p> <p>Actions are methods within a controller that handle specific requests, such as displaying a page, saving data, or performing particular operations.</p> <p>In summary, controllers organize the application's logic, and actions execute specific tasks in response to user requests.</p>"},{"location":"controllers_and_actions/#usage","title":"Usage","text":"Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\napp: App = App()\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, data: CreateUserRequestDto) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.create(data) #(1)\n        return Ok(CreateUserResponseDto(**user))\n\napp.map_controllers()\n</code></pre> <ol> <li> <p>Warning</p>    Simulated service for the example. </li> </ol> <p>This API can be consumed as follows:</p> Bash<pre><code>curl -X POST http://127.0.0.1:8000/user/create \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n           \"username\": \"superbad\",\n           \"password\": \"01-47-87441\",\n           \"confirm_password\": \"01-47-87441\",\n           \"name\": \"McLovin\",\n           \"birth_date\": \"1998-06-18\"\n         }'\n</code></pre> <p>This is the minimum required to create a API. The data will reach the <code>create</code> action of the <code>UserController</code> via the <code>POST</code> method and will be stored in the <code>data</code> object, which is of type <code>CreateUserRequestDto</code>. Finally, the response will be an object of type <code>CreateUserResponseDto</code>.</p> <p><code>ModelResponse</code> will be responsible for returning the data of all those objects (DTO) that inherit from <code>BaseModel</code>.</p> <p>NOTE: It is important to type the input data correctly to ensure proper data assignment.</p> <p>NOTE: To indicate to Cafeto that the application should use the controller actions, you must use: <code>app.map_controllers()</code>.</p> <p>Similarly, a traditional <code>JSONResponse</code> object from Starlette can be used for the response.</p> Python<pre><code>return JSONResponse({\"username\": \"jondoe\", ...})\n</code></pre> <p>For better control, it is recommended to use DTOs whenever possible. It is also useful for viewing documentation and testing APIs from Swagger.</p> <p>The available methods are:</p> <ul> <li>@app.post (POST)</li> <li>@app.put (PUT)</li> <li>@app.patch (PATCH)</li> <li>@app.get (GET)</li> <li>@app.delete (DELETE)</li> <li>@app.options (OPTIONS)</li> </ul> <p>Note: Only <code>POST</code> and <code>PUT</code> methods can receive data as input parameters, although it is not mandatory.</p> Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/activate')\n    async def activate(self) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.get() #(1)\n        return Ok(CreateUserResponseDto(**user))\n</code></pre> <ol> <li> <p>Warning</p>    Simulated service for the example. </li> </ol> <p>Note: If the <code>@app.controller</code> decorator does not have a parameter, the class name will be used without the word \"Controller\".</p> Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller() # No param\nclass UserController(BaseController):\n    @app.post('/activate')\n    async def activate(self) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.get() #(1)\n        return Ok(CreateUserResponseDto(**user))\n</code></pre> <ol> <li> <p>Warning</p>    Simulated service for the example. </li> </ol> <p>In this case, the URL will be: http://127.0.0.1:8000/user/activate</p>"},{"location":"dependency_injection/","title":"Dependency Injection","text":""},{"location":"dependency_injection/#introduction","title":"Introduction","text":"<p>Dependency injection is a design pattern that allows objects to receive their dependencies externally, rather than creating them themselves. This approach facilitates component management and promotes more modular and maintainable code.</p>"},{"location":"dependency_injection/#purpose","title":"Purpose","text":"<ul> <li>Simplifies unit testing.</li> <li>Facilitates maintenance and scalability.</li> <li>Reduces coupling between components.</li> </ul>"},{"location":"dependency_injection/#importance","title":"Importance","text":"<ul> <li>Improves code flexibility.</li> <li>Allows greater reuse of components.</li> <li>Facilitates the injection of different implementations or configurations at runtime.</li> </ul>"},{"location":"dependency_injection/#types","title":"Types","text":"<p>In the context of dependency injection, there are three main types of dependencies: <code>Singleton</code>, <code>Transient</code>, and <code>Scoped</code>. Each differs in how and when service instances are created throughout the application's lifecycle. These different ways of managing dependencies allow for better control over resource usage, efficiency, and state consistency in different application contexts.</p>"},{"location":"dependency_injection/#singleton","title":"Singleton","text":"<p>Description: A single instance of the dependency is created and shared throughout the application's lifetime.</p> <p>Use Cases: Used for configuration services, database connections, or any shared resource.</p>"},{"location":"dependency_injection/#scoped","title":"Scoped","text":"<p>Description: A single instance of the dependency is created and shared during the lifecycle of a request.</p> <p>Use Cases: Suitable for services that maintain state and need to be consistent during an HTTP request.</p>"},{"location":"dependency_injection/#transient","title":"Transient","text":"<p>Description: A new instance of the dependency is created each time it is requested.</p> <p>Use Cases: Ideal for lightweight services that do not maintain state and are short-lived.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant Service\n    participant Singleton_Instance\n    participant Scoped_Instance\n    participant Transient_Instance\n\n    Client-&gt;&gt;Server: Request\n    Server-&gt;&gt;Service: Call service\n\n    Service-&gt;&gt;Singleton_Instance: Check/Create instance\n    Singleton_Instance--&gt;&gt;Service: Provide instance\n    Note left of Singleton_Instance: The instance will never&lt;br&gt;be created again.\n\n    Service-&gt;&gt;Scoped_Instance: Check/Create instance (Per request)\n    Scoped_Instance--&gt;&gt;Service: Provide instance\n    Note left of Scoped_Instance: The instance will not be&lt;br&gt;created during this request&lt;br&gt;but will create a new one&lt;br&gt;in the next request.\n\n    Service-&gt;&gt;Transient_Instance: Create new instance (Each time)\n    Transient_Instance--&gt;&gt;Service: Provide instance\n    Note left of Transient_Instance: The instance will be&lt;br&gt;created each time it is&lt;br&gt;injected in this request&lt;br&gt;and in the next ones.\n\n    Service--&gt;&gt;Server: Return instance\n    Server--&gt;&gt;Client: Response</code></pre>"},{"location":"dependency_injection/#integration","title":"Integration","text":"<p>There are three methods to store dependencies as needed: <code>add_singleton</code>, <code>add_scoped</code>, <code>add_transient</code>.</p> Python<pre><code>from cafeto import App\n\napp: App = App()\n\napp.add_singleton()\napp.add_scoped()\napp.add_transient()\n</code></pre> <p>In the context of dependency injection, there are two main approaches: based on <code>interfaces</code> or <code>classes</code>. Below, each is explained and detailed when it is more appropriate to use one or the other.</p>"},{"location":"dependency_injection/#interface-based-dependency-injection","title":"Interface-Based Dependency Injection","text":"<p>This approach involves defining an interface and associating it with a concrete class. Although Python does not have interfaces as such, it is possible to use abstract classes with the <code>ABC</code> (Abstract Base Classes) module to achieve similar functionality.</p> <p>When to Use:</p> <ul> <li>Flexibility: Allows easily changing the implementation of the interface without modifying the dependent code.</li> <li>Unit Testing: Facilitates the creation of mock objects for testing.</li> <li>Decoupling: Reduces direct dependency between components, improving code maintainability.</li> </ul> Python<pre><code>from abc import ABC\nfrom typing import Optional\n\nfrom cafeto import App\n\nclass AUserService(ABC):\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        ...\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        ...\n\nclass UserService(AUserService):\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        try:\n            await &lt;some_database_connection&gt;.insert('users', user) #(1)\n            return True\n        except:\n            return False\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        try:\n            user = await &lt;some_database_connection&gt;.select('users', id) #(2)\n            return UserResponseDto(user)\n        except:\n            return None\n\napp: App = App()\napp.add_scoped(AUserService, UserService) # Store service\n</code></pre> <ol> <li> <p>Warning</p>    Simulated service for the example. </li> <li> <p>Warning</p> <p>Simulated service for the example.</p> </li> </ol> <p>In the example above, the dependency is stored using <code>AUserService</code> and <code>UserService</code>.</p>"},{"location":"dependency_injection/#why-is-this-useful","title":"Why is this useful?","text":"<p>Suppose that later in the project, it is required not to store users in a database but to send them to a microservice. In that case, we can create another class called <code>UserServiceToService</code> with the same methods, without needing to delete the current <code>UserService</code> class. This means that it will not be necessary to change the service call in each endpoint. Additionally, it allows us to keep the original <code>UserService</code> class in case it is needed in the future.</p> <p>This approach allows:</p> <ul> <li>Flexibility: Changing the implementation of services without affecting the dependent code.</li> <li>Decoupling: Maintaining a clear separation between the interface definition and its implementation, improving maintainability.</li> <li>Reuse: Allowing multiple implementations to coexist and be used in different contexts as needed.</li> </ul> <p>Now it is important to know how to inject the dependency, and for this, it is essential not to use <code>UserService</code> directly but <code>AUserService</code>, as it is through this interface that <code>UserService</code> will be reached. This ensures that the system can easily change the implementation of <code>AUserService</code> without affecting the dependent code, allowing greater flexibility and decoupling in your application.</p>"},{"location":"dependency_injection/#class-based-dependency-injection","title":"Class-Based Dependency Injection","text":"<p>This approach involves directly injecting a concrete class without using interfaces or abstract classes. It is less flexible but can be suitable for simple and direct implementations.</p> <p>When to Use:</p> <ul> <li>Simplicity: Suitable for small projects or when the implementation is not expected to change.</li> <li>Less Overhead: No need to define abstract classes or interfaces, simplifying development.</li> </ul> Python<pre><code>class CacheUserService:\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        try:\n            await &lt;some_cache_connection&gt;.insert('users', user) #(1)\n            return True\n        except:\n            return False\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        try:\n            user = await &lt;some_cache_connection&gt;.select('users', id) #(2)\n            return UserResponseDto(user)\n        except:\n            return None\n\napp: App = App()\napp.add_scoped(CacheUserService) # Store service\n</code></pre> <ol> <li> <p>Warning</p>    Simulated service for the example. </li> <li> <p>Warning</p> <p>Simulated service for the example.</p> </li> </ol> <p>In this case, unlike the previous example, only <code>CacheUserService</code> is used. This is because, during the project definition, it was estimated that the likelihood of this service changing is almost nil. Therefore, this approach was considered the most appropriate for this particular case.</p> <p>To inject this dependency, it is necessary to use <code>CacheUserService</code> directly, as there is no interface or abstract class associated with this implementation.</p>"},{"location":"dependency_injection/#comparison-and-use-in-python","title":"Comparison and Use in Python","text":"<p>In Python, since there are no formal interfaces like in other languages, it is possible to use abstract classes from the ABC module to achieve similar functionality. Here is a general comparison:</p> <p>Interface-Based Injection (ABC):</p> <ul> <li>Pros: Flexibility, ease of unit testing, less coupling.</li> <li>Cons: May add additional complexity.</li> </ul> <p>Class-Based Injection:</p> <ul> <li>Pros: Simplicity, faster development.</li> <li>Cons: Less flexibility, harder to change or test.</li> </ul>"},{"location":"dependency_injection/#generator","title":"Generator","text":"<p>The generator is another (optional) parameter when registering a dependency. Its function is to provide greater control over how the dependency is created and stored. It is a <code>Callable</code> that receives the necessary data for the registered dependency (<code>**data</code>).</p> Python<pre><code>class AMyService:\n    def __init__(self, other_service: AOtherService, extra_param: str) -&gt; None:\n        ...\n\nclass MyService:\n    def __init__(self, other_service: AOtherService, extra_param: str) -&gt; None:\n        self.other_service: AOtherService = other_service\n        self.extra_param: str = extra_param\n\ndef my_service_generator(**params):\n    params['extra_param'] = 'Hello World!'\n    return MyService(**params)\n\napp.add_scoped(AMyService, MyService, my_service_generator)\n</code></pre> <p>The abstract class is not mandatory, so the code could also be simplified as follows:</p> Python<pre><code>class MyService:\n    def __init__(self, other_service: AOtherService, extra_param: str) -&gt; None:\n        self.other_service: AOtherService = other_service\n        self.extra_param: str = extra_param\n\ndef my_service_generator(**params):\n    params['extra_param'] = 'Hello World!'\n    return MyService(**params)\n\napp.add_scoped(MyService, my_service_generator)\n</code></pre> <p>This offers greater flexibility in dependency injection, as the generator allows not only customizing the creation of the dependency but also performing any additional actions as needed.</p> <p>It is important to note that the generator will be invoked depending on the dependency's lifecycle (<code>Singleton</code>, <code>Scoped</code>, <code>Transient</code>):</p> <ul> <li>Singleton: The generator will be invoked only once during the entire project.</li> <li>Scoped: It will be executed once per request.</li> <li>Transient: It will be invoked each time the dependency needs to be injected.</li> </ul>"},{"location":"dependency_injection/#override","title":"Override","text":"<p>Determining if the dependency registration is an override requires an additional parameter, which serves to replace an already registered dependency. This parameter must be passed as a keyword argument, meaning it must be explicitly referenced using the parameter name.</p> Python<pre><code>app.add_scoped(MyService, override=True)\napp.add_scoped(AMyService, MyService, override=True)\napp.add_scoped(AMyService, MyService, my_generator, override=True)\n</code></pre>"},{"location":"dependency_injection/#removing-dependencies","title":"Removing Dependencies","text":"<p>To remove an existing dependency, you can use the <code>remove_&lt;type&gt;</code> method.</p> Python<pre><code>app.remove_singleton(MyServiceSingleton)\napp.remove_scoped(AMyServiceScoped)\napp.remove_transient(AMyServiceTransient)\n</code></pre>"},{"location":"dependency_injection/#injecting-dependencies","title":"Injecting Dependencies","text":"<p>Dependencies can be injected in various places, from the controller, DTO validation methods, and other dependencies. To make this possible, it is crucial to have previously stored them using one of the associated methods: <code>add_singleton</code>, <code>add_scoped</code>, or <code>add_transient</code>.</p> <p>In the case of controllers, they will be injected directly into the action.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok, NotFound\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/get/{id}')\n    async def get_by_id(self, id: int, service: AUserService) -&gt; UserResponseDto:\n        user = await service.get_by_id(id) #(1)\n        # Your code here\n</code></pre> <ol> <li> <p>Warning</p>    Simulated service for the example. </li> </ol> <p>In the case of DTO validators, they are used in each of these.</p> Python<pre><code>from typing import Any, Dict, List\n\nfrom cafeto.models import BaseModel, validate\nfrom cafeto.errors import FieldError, Error, ModelError\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str\n\n    @validate('username')\n    async def validate_username(value: str, data: Dict[str, Any], service: AUserService):\n        await service.some_required_validation() #(1)\n        # Your code here\n\n    @validate()\n    async def validate(value: str, data: Dict[str, Any], service: AUserService):\n        await service.some_required_validation() #(2)\n        # Your code here\n</code></pre> <ol> <li> <p>Warning</p>    Simulated service for the example. </li> <li> <p>Warning</p> <p>Simulated service for the example.</p> </li> </ol> <p>In the case of other dependencies, they are injected from the class constructor.</p> Python<pre><code>from abc import ABC\nfrom typing import Optional\n\nfrom cafeto import App\n\nclass AUserService(ABC):\n    def __init__(self, some_service: ASomeService) -&gt; None:\n        ...\n\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        ...\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        ...\n\nclass UserService(AUserService):\n    def __init__(self, some_service: ASomeService) -&gt; None:\n        self.some_service = some_service\n\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        await self.some_service.do_something_user(user) #(1)\n        # Your code here.\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        await self.some_service.do_something_id(id) #(1)\n        # Your code here.\n</code></pre> <ol> <li> <p>Warning</p>    Simulated service for the example. </li> <li> <p>Warning</p> <p>Simulated service for the example.</p> </li> </ol> <p>It is important to clarify that once the first dependency is initiated, it will create a recursive system where each dependency will be analyzed to correctly inject each one where needed.</p>"},{"location":"dependency_injection/#important-information","title":"Important Information","text":"<p><code>Singleton</code> type dependencies, being permanent, are shared among different users who enter the system in each request. This means that the information stored in these should preferably be information that is not related to the user's session and is immutable.</p>"},{"location":"dependency_injection/#why-is-this-important","title":"Why is this important?","text":"<ol> <li> <p>If information related to the user's session is stored, it could overlap between different requests, creating a security hole that could allow unauthorized access to certain services.</p> </li> <li> <p>If the information is mutable (regardless of type), it could be overwritten insecurely between concurrent requests. This is known as <code>Race Conditions</code>. Although there is a way to prevent it by using temporary resource locks, it is not recommended to avoid creating bottlenecks, as the lock can affect the overall system performance.</p> </li> </ol>"},{"location":"dependency_injection/#example","title":"Example","text":"Python<pre><code>import asyncio\nfrom typing import List\n\nclass MyServiceSingleton:\n    def __init__(self):\n        self.values: List[int] = []\n        self._lock = asyncio.Lock()\n\n    async def add_value(self, value: int) -&gt; None:\n        async with self._lock:  # Block the resource\n            self.values.append(value)\n\n    async def get_values(self) -&gt; List[int]:\n        async with self._lock: # Block the resource\n            return self.values\n</code></pre> <p>As shown in the example, this can cause undesired wait times. For this reason, it is recommended to opt for a <code>No Lock Contention</code> architecture to improve system efficiency.</p>"},{"location":"dependency_injection/#conclusion","title":"Conclusion","text":"<p>It is crucial to understand the three types of dependency injection (<code>Singleton</code>, <code>Transient</code>, and <code>Scoped</code>) and the two methods for implementing dependency injection, either through <code>interfaces</code> or <code>classes</code>. This understanding will allow you to design more flexible, maintainable, and scalable systems, adapting to the specific needs of each project.</p>"},{"location":"events/","title":"Events","text":""},{"location":"events/#introduction","title":"Introduction","text":"<p>Cafeto provides three types of events that can be used to perform global actions on requests. These actions will be applied to each action throughout the application and will be executed in the order they are added.</p> <p>Events are similar to Middleware but are simpler to implement and provide access to a wealth of system information about the current request.</p> <p>The events available in Cafeto are: <code>OnBeforeAction</code>, <code>OnExecuteAction</code>, and <code>OnAfterAction</code>.</p>"},{"location":"events/#onbeforeaction","title":"OnBeforeAction","text":"<p>This event is executed before the controller action is executed and receives two parameters: <code>controller: BaseController</code> and <code>action: Action</code>.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.events import OnBeforeAction\nfrom cafeto.types import Action\n\napp: App = App()\n\ndef get_on_before_action(controller: BaseController, action: Action):\n    # Your Code\n\nOnBeforeAction.add(get_on_before_action)\n</code></pre>"},{"location":"events/#onexecuteaction","title":"OnExecuteAction","text":"<p>This event is executed along with the controller action and receives three parameters: <code>controller: BaseController</code>, <code>action: Action</code>, and <code>request_model: BaseModel</code>.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.events import OnExecuteAction\nfrom cafeto.types import Action\n\napp: App = App()\n\ndef get_on_execute_action(controller: BaseController, action: Action, request_model: BaseRequest):\n    # Your Code\n\nOnExecuteAction.add(get_on_execute_action)\n</code></pre>"},{"location":"events/#onafteraction","title":"OnAfterAction","text":"<p>This event is executed after the controller action is executed and receives four parameters: <code>controller: BaseController</code>, <code>action: Action</code>, <code>request_model: BaseModel</code>, and <code>response: Response</code>.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.events import OnAfterAction\nfrom cafeto.types import Action\nfrom cafeto.responses import Response\n\napp: App = App()\n\ndef get_on_after_action(controller: BaseController, action: Action, request_model: BaseRequest, response: Response):\n    # Your Code\n\nOnAfterAction.add(get_on_after_action)\n</code></pre> <p>Events can also be removed.</p> Python<pre><code>OnAfterAction.remove(get_on_after_action)\n</code></pre> <p>Events can also be asynchronous.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.events import OnAfterAction\nfrom cafeto.types import Action\nfrom cafeto.responses import Response\n\napp: App = App()\n\nasync def get_on_after_action(controller: BaseController, action: Action, request_model: BaseRequest, response: Response):\n    # Your Code\n\nOnAfterAction.add(get_on_after_action)\n</code></pre>"},{"location":"params/","title":"Parameters","text":""},{"location":"params/#introduction","title":"Introduction","text":"<p>Parameters in an API are key elements that allow customizing requests and responses. They are divided into three main types:</p> Path Parameters <p>Define variable parts of the URL.</p> <p>Importance: Allow direct and structured access to specific resources.</p> Query String Parameters <p>Are added to the URL after the <code>?</code> symbol and are separated by <code>&amp;</code>.</p> <p>Importance: Facilitate filtering, sorting, and customizing results without modifying the path.</p> Headers <p>Are sent as part of the HTTP request.</p> <p>Importance: Provide metadata about the request, such as authentication, content format, and more.</p> <p>These parameters are essential for the flexibility, security, and efficiency of communication between the client and the server in an API.</p>"},{"location":"params/#path-parameters","title":"Path Parameters","text":"<p>It is possible to obtain parameters in the URL as done in Starlette, but they will be obtained as a parameter in the action.</p> Python<pre><code>from typing import Dict\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/get-params/{id}')\n    async def get_params(self, id: int) -&gt; Dict[str, int]:\n        return Ok({'id': id})\n</code></pre> <p>The API can be consumed like this:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params/1 \\\n     -H \"Content-Type: application/json\"\n</code></pre> <p>Note: Unlike Starlette, the parameter type is not defined in the URL but in the action parameter:</p> <p>Danger</p> <p>Incorrect way</p> Python<pre><code>@app.get('/get-params/{id:int}')\nasync def get_params(self, id):\n    ...\n</code></pre> <p>Success</p> <p>Correct way</p> Python<pre><code>@app.get('/get-params/{id}')\nasync def get_params(self, id: int):\n    ...\n</code></pre> <p>These parameters are mandatory and can be defined as many as needed.</p> Python<pre><code>from typing import Dict, Any\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/get-params/{id}/{group}')\n    async def get_params(self, id: int, group: str) -&gt; Dict[str, Any]:\n        return Ok({'id': id, 'group': group})\n</code></pre> <p>The API can be consumed like this:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params/1/employee \\\n     -H \"Content-Type: application/json\"\n</code></pre>"},{"location":"params/#query-string-parameters","title":"Query String Parameters","text":"<p>It is possible to obtain parameters from the query string like this:</p> Python<pre><code>from typing import Dict\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/get-params', query=['group'])\n    async def get_params(self, group: str) -&gt; Dict[str, str]:\n        return Ok({'group': group})\n</code></pre> <p>The API can be consumed like this:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params?group=employee \\\n     -H \"Content-Type: application/json\" \n</code></pre>"},{"location":"params/#header-parameters","title":"Header Parameters","text":"<p>It is possible to obtain parameters from the headers like this:</p> Python<pre><code>from typing import Dict\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/get-params', headers=['token'])\n    async def get_params(self, token: str) -&gt; Dict[str, str]:\n        return Ok({'token': token})\n</code></pre> <p>The API can be consumed like this:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params \\\n     -H \"Content-Type: application/json\" \\\n     -H \"token: token123\" \n</code></pre> <p>It is possible to obtain multiple parameters from the three different sources like this:</p> Python<pre><code>from typing import Dict, Any\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get(\n        '/get-params/{id}/{group}',\n        query=['confirm'],\n        headers=['token', 'language'])\n    async def get_params(\n        self,\n        id: int,\n        token: str,\n        confirm: int,\n        group: str,\n        language: str) -&gt; Dict[str, Any]:\n        return Ok({\n            'id': id,\n            'token': token,\n            'confirm': confirm,\n            'group': group,\n            'language': language\n        })\n</code></pre> <p>The API can be consumed like this:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params/1/employee?confirm=1 \\\n     -H \"Content-Type: application/json\" \\\n     -H \"token: token123\" \\\n     -H \"language: esCO\" \n</code></pre> <p>As seen in the previous example, the order of the parameters does not really matter.</p> <p><code>Header</code> and <code>query string</code> parameters can have default values. This means that if the parameter is not found, the default value assigned in the action definition will be used.</p> Python<pre><code>from typing import Dict\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/create', query=['group'])\n    async def create(self, group: str='employee') -&gt; Dict[str, str]:\n        return Ok({'group': group})\n</code></pre> <p>In this last example, <code>group</code> has a default value, so it must be at the end of the parameters and this value will be used if the parameter is not found in the <code>query string</code>.</p>"},{"location":"request/","title":"Request","text":""},{"location":"request/#introduction","title":"Introduction","text":"<p>A request in a service is a petition that a client sends to a server to perform a specific operation. This request includes key information such as the HTTP method (GET, POST, PUT, DELETE, etc.), the URL that identifies the requested resource, headers containing contextual data (like authentication or content type), and optionally, a body that holds additional data needed to process the request, such as forms or JSON. The server processes the request and returns a response indicating the result of the operation.</p> <p>Requests are received through a DTO (Data Transfer Object). It is a way to encapsulate data in a structured and typed format to ensure that information is transmitted consistently and securely.</p>"},{"location":"request/#usage","title":"Usage","text":"Python<pre><code>from datetime import date\nfrom typing import Optional\n\nfrom cafeto import App\nfrom cafeto.models import BaseModel\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\nclass ExtraDataRequestDto(BaseModel):\n    nickname: str\n\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str\n    confirm_password: str\n    name: Optional[str]\n    birth_date: date\n    extra_data: ExtraDataRequestDto\n\napp: App = App()\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, user: CreateUserRequestDto) -&gt; Dict[str, Any]: #(1)\n        return Ok({\n            'username': user.username,\n            'password': user.password,\n            'name': user.name,\n            'birth_date': user.birth_date,\n            'extra_data': {\n                'nickname': user.extra_data.nickname\n            }\n        })\n\napp.map_controllers()\n</code></pre> <ol> <li>Here the <code>CreateUserRequestDto</code> object is received. Python<pre><code>    async def create(self, user: CreateUserRequestDto)\n</code></pre></li> </ol> <p>For this example, you only need to map the fields of the <code>CreateUserRequestDto</code> class, including the <code>ExtraDataRequestDto</code> class in a JSON like this:</p> Bash<pre><code>curl -X POST http://127.0.0.1:8000/user/create \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n           \"username\": \"jon-d\",\n           \"password\": \"my-password-123\",\n           \"confirm_password\": \"my-password-123\",\n           \"name\": \"Jon Doe\",\n           \"birth_date\": \"1984-01-01\",\n           \"extra_data\": {\n            \"nickname\": \"Jon\"\n           }\n         }'\n</code></pre>"},{"location":"request/#file-upload","title":"File Upload","text":"<p>It is possible to create an action to upload files. For this, the request must be of type <code>UploadFile</code>.</p> Python<pre><code>from cafeto import App\nfrom cafeto.datastructures import UploadFile\nfrom cafeto.models import BaseModel\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass StorageController(BaseController):\n    @app.post('/upload')\n    async def upload(self, file: UploadFile) -&gt; Ok:\n        return Ok({'file': file.filename})\n</code></pre> <p>The API can be consumed like this:</p> Bash<pre><code>curl -X POST http://127.0.0.1:8000/upload \\\n     -F \"file=@path/to/your/file\"\n</code></pre>"},{"location":"response/","title":"Responses","text":""},{"location":"response/#introduction","title":"Introduction","text":"<p>The response of a service is the result sent to the client after processing a request. It can have different formats depending on the need, such as JSON for structured data, plain text for simple messages, HTML for web content, binary files for downloads, or even streaming responses for progressively sent data. Its content and status code (like 200 for success or 400 for errors) indicate the result of the operation performed.</p> <p>In its actions, Cafeto uses the standard responses from <code>Starlette</code>, which include: <code>JSON</code>, <code>HTML</code>, <code>Plain Text</code>, <code>Binary Files</code>, <code>Streaming</code>, or <code>None</code> (no content). Additionally, Cafeto offers two extra responses to handle DTOs: <code>ModelResponse</code> and <code>ModelWSResponse</code> (specific for websockets). This approach is called the <code>Classic Method</code>.</p> <p>Complementing the responses of the <code>Classic Method</code>, Cafeto introduces an additional system called the <code>Unified Method</code>.</p> <p>The main difference is that in the <code>Classic Method</code>, the developer must manually choose the type of response according to the data to be returned. In contrast, the <code>Unified Method</code> always uses a single response that can automatically detect the type of data to be returned, simplifying the process.</p> <p>In the <code>Classic Method</code>, the default status code (<code>statusCode</code>) is always <code>200</code>, and it must be adjusted manually according to the needs. On the other hand, in the <code>Unified Method</code>, each type of response is automatically associated with a specific status code.</p> Unified StyleClassic Style <ul> <li>Ok (Response with status code 200)</li> <li>BadRequest (Response with status code 400)</li> <li>NoContent (Response with status code 204)</li> <li>ETC...</li> </ul> <ul> <li>Response (No content response)</li> <li>JSONResponse (JSON response)</li> <li>PlainTextResponse (Plain text response)</li> <li>HTMLResponse (HTML formatted text response)</li> <li>FileResponse (Binary file response)</li> <li>StreamingResponse (Streaming response)</li> <li>ModelResponse (Model response)</li> <li>ModelWSResponse (Model response, but from a websocket)</li> </ul>"},{"location":"response/#json-response","title":"JSON Response","text":"Unified StyleClassic Style Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; Dict[str, str]:\n        return Ok({'Hello': 'Hola'})\n</code></pre> Python<pre><code>from cafeto.responses import JSONResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; JSONResponse:\n        return JSONResponse({'Hello': 'Hola'})\n</code></pre> <p>It is important to remember that the response type of the actions is not strictly mandatory and is only used for documentation with OpenApi, but it is suggested to use it to have a clearer and easier to maintain project.</p> Unified StyleClassic Style Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self):  # No response\n        return Ok({'Hello': 'Hola'})\n</code></pre> Python<pre><code>from cafeto.responses import JSONResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self):  # No response\n        return JSONResponse({'Hello': 'Hola'})\n</code></pre>"},{"location":"response/#dto-response","title":"DTO Response","text":"Unified StyleClassic Style Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.get() #(1)\n        return Ok(CreateUserResponseDto(**user)) #(2)\n</code></pre> <ol> <li> <p>Warning</p> <p>Simulated service for the example.</p> </li> <li> <p>Here the <code>CreateUserResponseDto</code> object is sent.</p> </li> </ol> Python<pre><code>from cafeto.responses import ModelResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.get() #(1)\n        return ModelResponse(CreateUserResponseDto(**user)) #(2)\n</code></pre> <ol> <li> <p>Warning</p> <p>Simulated service for the example.</p> </li> <li> <p>Here the <code>CreateUserResponseDto</code> object is sent.</p> </li> </ol>"},{"location":"response/#list-of-dtos-response","title":"List of DTOs Response","text":"Unified StyleClassic Style Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; List[CreateUserResponseDto]:\n        users = &lt;some_user_service&gt;.get_all()\n        return Ok(\n            [CreateUserResponseDto(**user) for user in users]\n        )\n</code></pre> Python<pre><code>from cafeto.responses import ModelResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; List[CreateUserResponseDto]:\n        users = &lt;some_user_service&gt;.get_all()\n        return ModelResponse(\n            [CreateUserResponseDto(**user) for user in users]\n        )\n</code></pre>"},{"location":"response/#no-content-response","title":"No Content Response","text":"Unified StyleClassic Style Python<pre><code>from cafeto.responses import NoContent\n\n@app.controller()\nclass UserController:\n    @app.post('/check')\n    async def check(self) -&gt; None:\n        return NoContent()\n</code></pre> Python<pre><code>from cafeto.responses import Response\n\n@app.controller()\nclass UserController:\n    @app.post('/check')\n    async def check(self) -&gt; Response:\n        return Response()\n</code></pre>"},{"location":"response/#file-or-binary-response","title":"File or Binary Response","text":"Unified StyleClassic Style Python<pre><code>from cafeto.responses import Ok, FileResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; FileResponse:\n        return Ok(FileResponse('/path/to/file'))\n</code></pre> Python<pre><code>from cafeto.responses import FileResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; FileResponse:\n        return FileResponse('/path/to/file')\n</code></pre>"},{"location":"response/#plain-text-response","title":"Plain Text Response","text":"Unified StyleClassic Style Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; str:\n        return Ok('Hello World!')\n</code></pre> Python<pre><code>from cafeto.responses import PlainTextResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; PlainTextResponse:\n        return PlainTextResponse('Hello World!')\n</code></pre>"},{"location":"response/#html-response","title":"HTML Response","text":"Unified StyleClassic Style Python<pre><code>from cafeto.responses import Ok, Format\nfrom cafeto.responses.types import TEXT_HTML\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; Format[str, TEXT_HTML]:\n        return Ok('&lt;div&gt;Hello World!&lt;/div&gt;', format=TEXT_HTML)\n</code></pre> Python<pre><code>from cafeto.responses import HTMLResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; HTMLResponse:\n        return HTMLResponse('&lt;div&gt;Hello World!&lt;/div&gt;')\n</code></pre>"},{"location":"response/#streaming-response","title":"Streaming Response","text":"Unified StyleClassic Style Python<pre><code>from cafeto.responses import Ok, Format\nfrom cafeto.responses.types import TEXT_HTML\n\nasync def slow_numbers(minimum, maximum):\n    yield '&lt;ul&gt;'\n    for number in range(minimum, maximum + 1):\n        yield f'&lt;li&gt;{number}&lt;/li&gt;'\n        await asyncio.sleep(0.5)\n    yield '&lt;/ul&gt;'\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; Format[str, TEXT_HTML]:\n        generator = slow_numbers(1, 10)\n        return Ok(generator, format=TEXT_HTML)\n</code></pre> Python<pre><code>from cafeto.responses import StreamingResponse\n\nasync def slow_numbers(minimum, maximum):\n    yield '&lt;ul&gt;'\n    for number in range(minimum, maximum + 1):\n        yield f'&lt;li&gt;{number}&lt;/li&gt;'\n        await asyncio.sleep(0.5)\n    yield '&lt;/ul&gt;'\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; HTMLResponse:\n        generator = slow_numbers(1, 10)\n        return StreamingResponse(generator)\n</code></pre>"},{"location":"response/#conclusion","title":"Conclusion","text":"<p>Both systems are quite good, each with its pros and cons. It is up to each developer to use one or the other. It is recommended to choose one from the beginning to avoid confusion and not to combine the two systems, thus having greater order and control over the system.</p>"},{"location":"schema/","title":"Schema","text":""},{"location":"schema/#introduction","title":"Introduction","text":"<p>Using a schema like OpenAPI to display the inputs and outputs of an API offers several significant advantages:</p> <ul> <li> <p>Clear and detailed documentation: OpenAPI allows you to create comprehensive documentation that describes the endpoints, HTTP methods, parameters, responses, and other elements of the API. This makes it easier for other developers to understand and use the API.</p> </li> <li> <p>Facilitates collaboration: With well-defined documentation, development teams can collaborate more effectively. Developers can quickly understand how to interact with the API, reducing the need for additional communication.</p> </li> <li> <p>Simplifies testing and debugging: Tools like Swagger UI provide an interactive graphical interface for testing and exploring APIs. This allows developers and testers to quickly verify the functionality of endpoints and detect potential errors.</p> </li> <li> <p>Standardization: OpenAPI follows a recognized standard for defining and describing APIs. This ensures that the documentation is consistent and understandable, regardless of who created it.</p> </li> <li> <p>Automatic code generation: Many tools can automatically generate client and server code from an OpenAPI specification. This speeds up development and ensures that the generated code is aligned with the documentation.</p> </li> <li> <p>Improves maintainability: Having up-to-date and accurate documentation makes it easier to maintain the API. Changes to endpoints, parameters, or responses can be quickly reflected in the documentation, ensuring that all API users are aware of the modifications.</p> </li> <li> <p>Data validation: OpenAPI allows you to define validation schemas for the API's inputs and outputs. This ensures that the data sent and received meets the expected formats, reducing errors and improving the robustness of the API.</p> </li> <li> <p>Security: The OpenAPI specification allows you to define security schemes, such as authentication and authorization, which help ensure that the API is protected against unauthorized access.</p> </li> </ul> <p>In summary, using a schema like OpenAPI to document the inputs and outputs of an API provides clarity, facilitates collaboration, improves maintainability and security, and allows you to leverage advanced tools for testing and code generation.</p>"},{"location":"schema/#openapi","title":"OpenAPI","text":"<p>OpenAPI specifies a standard for defining and describing APIs. With OpenAPI, you can create clear and detailed documentation that describes the endpoints, HTTP methods, parameters, responses, and other elements of your API. This makes it easier for other developers to understand and use the API.</p>"},{"location":"schema/#swagger","title":"Swagger","text":"<p>Swagger is a set of tools built around the OpenAPI specification. It includes Swagger UI, which provides an interactive graphical interface for testing and exploring APIs.</p>"},{"location":"schema/#integration","title":"Integration","text":"<p>To enable integration with OpenAPI and Swagger, you just need to activate them.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\n\n\napp: App = App(debug=True)\n\n@app.controller()\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, data: CreateUserRequestDto) -&gt; CreateUserResponseDto:\n        # My code here\n\napp.map_controllers()\napp.use_schema()\nif app.debug:\n    app.use_swagger()\n</code></pre> <p>There are two entry points to view the OpenAPI documentation in <code>json</code> and <code>yaml</code> format:</p> <ul> <li>http://127.0.0.1:8000/schema/openapi.json</li> <li>http://127.0.0.1:8000/schema/openapi.yaml</li> </ul> <p>And to view the Swagger UI interface, go to:</p> <ul> <li>http://127.0.0.1:8000/schema/swagger-ui.html</li> </ul>"},{"location":"schema/#documentation","title":"Documentation","text":"<p>The OpenAPI documentation will be automatically created using the actions of the controllers as the data source. Relevant information includes output data (the response of the actions) and input data, including request parameters such as <code>path</code>, <code>query string</code>, <code>headers</code>, and the data they return. It will also consider if the actions have access control with the <code>@app.requires</code> decorator.</p> <p>It is also a good idea to provide general documentation about the API.</p> Python<pre><code>from cafeto import SecurityScheme, Info, Contact, License, ExternalDocs\n\n\nsecurity_scheme: SecurityScheme = SecurityScheme(\n    name='auth',\n    bearer_format='JWT',\n    type='http',\n    scheme='bearer'\n)\n\ninfo: Info = Info(\n    title='My API',\n    description='Lorem ipsum dolor sit amet, consectetuer adipiscing elit.',\n    version='1.0.0',\n    terms_of_service='http://my_api_terms_of_service.html',\n    contact=Contact(\n        name='Cafeto',\n        url='http://my_api_contact.html',\n        email='my_api@email.com'\n    ),\n    license=License(\n        name='My License',\n        url='http://my_license.html'\n    )\n)\n\nexternal_docs: ExternalDocs = ExternalDocs(\n    description='Find more info here',\n    url='http://my_docs.html'\n)\n\napp.use_schema(\n    openapi_version='3.0.1', # Default\n    info=info,\n    security_scheme=security_scheme,\n    external_docs=external_docs\n)\n</code></pre> <p>It is possible to add additional documentation to controllers and actions using Python docstrings.</p> Python<pre><code>@app.controller()\nclass HomeController(BaseController):\n    '''\n    description: Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n    '''\n    @app.get('/hello')\n    async def hello(self) -&gt; UserResponseDto:\n        '''\n        summary: Lorem ipsum.\n        description: Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n        responses:\n            200:\n                default: true\n                description: Lorem ipsum\n            400:\n                description: Lorem ipsum\n        '''\n</code></pre> <p>The format used for this documentation is <code>yml</code>. In the action documentation, in the <code>responses</code> section, there is the <code>default</code> option. If this is set to <code>true</code>, it means that this response corresponds to the data that the action will return.</p>"},{"location":"sponsor/","title":"Sponsor","text":""},{"location":"sponsor/#introduction","title":"Introduction","text":"<p>Open source projects rely heavily on the support and contributions from the community. Donations play a crucial role in sustaining the development, maintenance, and growth of these projects. By donating, you help ensure that the project can continue to improve, add new features, and provide timely updates. Your support is invaluable in keeping the project alive and thriving.</p>"},{"location":"starlette_request_object/","title":"Request Object (Starlette)","text":""},{"location":"starlette_request_object/#introduction","title":"Introduction","text":"<p>In Starlette, the <code>request</code> object represents the HTTP request that arrives at an endpoint. It contains information such as the request methods (GET, POST, etc.), headers, path parameters, query string, request body, and more. It is essential for accessing and manipulating the incoming request data in your application.</p> <p>The <code>Request</code> object from Starlette is not lost and can still be accessed from the controller.</p>"},{"location":"starlette_request_object/#usage","title":"Usage","text":"Python<pre><code>from cafeto import Response\nfrom cafeto.mvc import BaseController\n\n\n@app.controller()\nclass HomeController(BaseController):\n    @app.get('/hello')\n    async def hello(self) -&gt; Response:\n        print(self.request)  # Request object\n        return Response()\n</code></pre> <p>If the action is a websocket, you should use:</p> Python<pre><code>from cafeto import Response\nfrom cafeto.mvc import BaseController\n\n\n@app.controller()\nclass HomeController(BaseController):\n    @app.websocket('/ws')\n    async def hello(self) -&gt; Response:\n        print(self.websocket)  # Request object\n        return Response()\n</code></pre>"},{"location":"validations/","title":"Validations","text":""},{"location":"validations/#introduction","title":"Introduction","text":"<p>Validations in an API are processes that verify that the data sent to the server meets certain rules or criteria before being processed. This ensures that the information is correct, complete, and secure.</p>"},{"location":"validations/#importance","title":"Importance","text":"<ul> <li>Error Prevention: Prevents incorrect data from causing system failures.</li> <li>Security: Protects against code injections and other attacks.</li> <li>Data Integrity: Ensures that stored and processed data is consistent and reliable.</li> <li>User Experience: Provides immediate feedback on errors in the submitted data.</li> </ul> <p>Essential for robust and secure API operation!</p>"},{"location":"validations/#usage","title":"Usage","text":"<p>In Cafeto, DTOs will execute the validations that Pydantic has available by default.</p> Python<pre><code>from typing import Optional\nfrom pydantic import Field\nfrom cafeto import BaseModel\n\n\nclass CreateUserRequestDto(BaseModel):\n    username: str = Field(min_length=3)\n    password: str\n    confirm_password: str\n    name: Optional[str]\n    birth_date: date\n</code></pre> <p>In the example above, the fields <code>username</code>, <code>password</code>, <code>confirm_password</code>, and <code>birth_date</code> are required, while the <code>name</code> field is optional, and the <code>username</code> field has a minimum length of 3 characters. These validations will be executed automatically when the action is consumed, and errors will be returned with a <code>statusCode</code> of <code>400</code>.</p> <p>For custom validations, there is the <code>@validate</code> decorator. This decorator takes the name of the field to be validated as a parameter; if this field is not provided, the entire DTO will be validated.</p> Python<pre><code>from datetime import date\nfrom typing import Any, Optional, Dict, List\n\nfrom pydantic import Field\nfrom cafeto import App\nfrom cafeto.models import BaseModel, validate\nfrom cafeto.errors import FieldError, ModelError, Error\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\nclass ExtraDataRequestDto(BaseModel):\n    nickname: str\n\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str = Field(min_length=3)\n    confirm_password: str\n    name: Optional[str]\n    birth_date: date\n    extra_data: ExtraDataRequestDto\n\n    @validate('password') #(1)\n    def validate_password(value: str, data: Dict[str, Any]) -&gt; str:\n        if value != data.get('confirm_password', None):\n            raise FieldError(Error('same-password', 'Password and confirm password must be the same'))\n        return value\n\n    @validate('birth_date') #(2)\n    def validate_birth_date(value: date, data: Dict[str, Any]) -&gt; date:\n        if value.year &lt;= 2000:\n            raise FieldError(Error('year-error', 'The year must be greater than 2000'))\n        return value\n\n    @validate() #(3)\n    async def validate(data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        errors: List[Error] = []\n        errors.append(Error('user-custom', 'Custom error'))\n        if len(errors) &gt; 0:\n            raise ModelError(errors)\n\n        return data\n\napp: App = App()\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, user: CreateUserRequestDto) -&gt; Dict[str, str]:\n        return Ok({'hello': 'HomepageController'})\n\napp.map_controllers()\n</code></pre> <ol> <li> <p>Validates the <code>password</code> field.</p> </li> <li> <p>Validates the <code>birth_date</code> field.</p> </li> <li> <p>Validates the entire model.</p> </li> </ol> <p>The <code>@validate</code> decorator is similar to Pydantic's <code>@field_validator</code> and was developed to create custom and asynchronous validations. It also supports dependency injection in the method to which it is applied.</p> Bash<pre><code>curl -X PUT http://127.0.0.1/user/create \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n           \"password\": \"pa\",\n           \"confirm_password\": \"other-password-123\",\n           \"birth_date\": \"1998-06-18\",\n           \"extra_data\": {}\n         }'\n</code></pre> <p>If we send the above request, we will get the following result:</p> JSON<pre><code>{\n    \"errorList\": [\n        {\n            \"loc\": [\n                \"__model__\"\n            ],\n            \"type\": \"user-custom\",\n            \"msg\": \"Custom error\"\n        },\n        {\n            \"loc\": [\n                \"password\"\n            ],\n            \"type\": \"same-password\",\n            \"msg\": \"Password and confirm password must be the same\"\n        },\n        {\n            \"loc\": [\n                \"birth_date\"\n            ],\n            \"type\": \"year-error\",\n            \"msg\": \"The year must be greater than 2000\"\n        },\n        {\n            \"loc\": [\n                \"username\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        },\n        {\n            \"loc\": [\n                \"password\"\n            ],\n            \"type\": \"string_too_short\",\n            \"msg\": \"String should have at least 3 characters\"\n        },\n        {\n            \"loc\": [\n                \"name\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        },\n        {\n            \"loc\": [\n                \"extra_data\",\n                \"nickname\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        }\n    ]\n}\n</code></pre> <p>This is more or less the same format in which Pydantic returns data validation.</p> <p><code>FieldError</code> is used to throw an exception when a DTO field fails and takes an <code>Error</code> object as a parameter, which in turn takes the parameters <code>type: str</code> and <code>msg: str</code>. There is a third parameter called <code>loc: List[str | int] | str | int</code>; if this is not used, Pydantic will do it automatically.</p> <p>In the <code>loc</code> array, the word <code>__model__</code> refers to global errors, i.e., those not necessarily associated with any DTO field.</p>"},{"location":"validations/#important-information","title":"Important Information","text":"<p>It is important to note that these methods are static, so they do not receive the <code>self</code> parameter.</p> <p>The parameters of the method where the <code>@validate</code> decorator is applied are: <code>value</code> and <code>data</code>.</p> <ol> <li> <p>value: It is the current value of the field being validated, and the data type will be the one configured from the model.</p> <p>Note: If the validator applies to the entire model, the first parameter will be a dictionary with the data of the entire model.</p> </li> <li> <p>data: It is a dictionary with the other fields of the model.</p> <p>Note: If the validator applies to the entire model, the second parameter does not exist.</p> </li> </ol> <p>As a general rule, if the second parameter is not needed, it is usually called \"_\" (underscore).</p> Python<pre><code>@validate('birth_date') #(2)\ndef validate_birth_date(value: date, _: Dict[str, Any]) -&gt; date:\n</code></pre>"},{"location":"validations/#error-format","title":"Error Format","text":"<p>There is an additional way to return errors; for this, the application must be configured to return them in this format.</p> Python<pre><code>from cafeto import CafetoConfig\n\nconfig: CafetoConfig = CafetoConfig(error_object=True)\napp: App = App(config=config)\n</code></pre> <p>In that case, errors will be thrown in both the previously seen format and the new one.</p> JSON<pre><code>{\n    \"errorList\": [\n        {\n            \"loc\": [\n                \"__model__\"\n            ],\n            \"type\": \"user-custom\",\n            \"msg\": \"Custom error\"\n        },\n        {\n            \"loc\": [\n                \"password\"\n            ],\n            \"type\": \"same-password\",\n            \"msg\": \"Password and confirm password must be the same\"\n        },\n        {\n            \"loc\": [\n                \"birth_date\"\n            ],\n            \"type\": \"year-error\",\n            \"msg\": \"The year must be greater than 2000\"\n        },\n        {\n            \"loc\": [\n                \"username\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        },\n        {\n            \"loc\": [\n                \"password\"\n            ],\n            \"type\": \"string_too_short\",\n            \"msg\": \"String should have at least 3 characters\"\n        },\n        {\n            \"loc\": [\n                \"name\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        },\n        {\n            \"loc\": [\n                \"extra_data\",\n                \"nickname\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        }\n    ],\n    \"errorObject\": {\n        \"__model__\": [\n            {\n                \"type\": \"user-custom\",\n                \"msg\": \"Custom error\"\n            }\n        ],\n        \"password\": [\n            {\n                \"type\": \"same-password\",\n                \"msg\": \"Password and confirm password must be the same\"\n            },\n            {\n                \"type\": \"string_too_short\",\n                \"msg\": \"String should have at least 3 characters\"\n            }\n        ],\n        \"birth_date\": [\n            {\n                \"type\": \"year-error\",\n                \"msg\": \"The year must be greater than 2000\"\n            }\n        ],\n        \"username\": [\n            {\n                \"type\": \"missing\",\n                \"msg\": \"Field required\"\n            }\n        ],\n        \"name\": [\n            {\n                \"type\": \"missing\",\n                \"msg\": \"Field required\"\n            }\n        ],\n        \"extra_data\": {\n            \"nickname\": [\n                {\n                    \"type\": \"missing\",\n                    \"msg\": \"Field required\"\n                }\n            ]\n        }\n    }\n}\n</code></pre> <p>In this case, two types of errors are thrown: <code>errorList</code> and <code>errorObject</code>. In the latter, the <code>loc</code> field no longer exists and becomes the nested keys of the object with the errors.</p>"},{"location":"validations/#modifying-values","title":"Modifying Values","text":"<p>The <code>@validate</code> decorator also serves to modify the DTO values when returned, i.e., it can be used not only to validate data but also to alter their values.</p> <p>Note: It is important to note that validators always must return a value; this value will be the one finally used in the model.</p> Python<pre><code>class MyModelDto(BaseModel):\n    name: str\n\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        return value + ' - Hello'\n</code></pre> <p>The value of the <code>name</code> field will be the assigned value + \" - Hello\".</p>"},{"location":"validations/#nested-models","title":"Nested Models","text":"<p>If you need to validate a model where one of its fields is another model, you must pay attention to how these are validated. If we use the <code>@validate</code> decorator on the field that contains the nested model, the custom validations of this model will not be executed. This is because the system must determine which validation to execute and will prioritize the one that is less nested in the model.</p> Python<pre><code>class MyModelA(BaseModel):\n    name_a: str\n\n    @validate('name_a')\n    def validate_name_a(value: str, _: Dict[str, Any]) -&gt; str:\n        return value + ' - Hello A from MyModelA'\n\n\nclass MyModelB(BaseModel):\n    name_b: str\n    model_a: MyModelA\n\n    @validate('name_b')\n    def validate_name_b(value: str, _: Dict[str, Any]) -&gt; str:\n        return value + ' - Hello B'\n\n    @validate('model_a')\n    def validate_model_a_from_b(value: MyModelA, _: Dict[str, Any]) -&gt; MyModelA:\n        value.name_a += ' - Hello A from MyModelB'\n        return value\n</code></pre> <p>In this last example, the <code>validate_name_a</code> validation and any other in the <code>MyModelA</code> model will not be executed because the <code>validate_model_a_from_b</code> validation in the <code>MyModelB</code> model is overwriting it.</p>"},{"location":"validations/#validators","title":"Validators","text":"<p>As seen in the previous examples, validations are associated with DTOs. However, it may not always be desirable to have this behavior. For these cases, there are validators. These are classes to which the <code>@validate</code> decorator is also applied, either to validate a field or the entire model, just like DTOs. To use these validators, you only need to inherit from the <code>BaseValidator</code> class.</p> Python<pre><code>from cafeto.models import BaseValidator, validate\n\nclass MyValidator(BaseValidator):\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        if value == '??':\n            raise FieldError(Error('name-error', 'Name Error'))\n        return value\n</code></pre> <p>Dependencies can also be injected into validators, just like DTOs.</p> Python<pre><code>from cafeto.models import BaseValidator, validate\n\nclass MyValidator(BaseValidator):\n    @validate()\n    async def validate_model(value: Dict[str, Any], some_service: ASomeService) -&gt; Dict[str, Any]:\n        result = await some_service.validate_user(value.get('user'))\n        if not result:\n            raise ModelError([Error('name-error', 'Name Error')])\n        return value\n</code></pre> <p>To use the validator, it must be configured in the controller action. This is done in the <code>body</code> parameter of the <code>@app.get</code>, <code>@app.post</code>, <code>@app.put</code>, <code>@app.patch</code>, and <code>@app.delete</code> decorators.</p> Python<pre><code>from cafeto.models import BaseModel, BaseValidator, validate\nfrom cafeto.mvc import BaseController\n\nclass MyDto(BaseModel):\n    name: str\n    age: int\n\n\nclass MyValidator(BaseValidator):\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        if value == '??':\n            raise FieldError(Error('name-error', 'Name Error'))\n        return value\n\n\n@app.controller()\nclass MyController(BaseController):\n    @app.post('/create', body={'validator': MyValidator})\n    async def create(self, request: MyDto):\n        # Code\n</code></pre> <p>In this example, the DTO's own validations, such as the required fields (<code>name</code>, <code>age</code>), will be applied. Additionally, custom validations will be executed using the <code>MyValidator</code> validator. This is particularly useful if you want to keep a cleaner DTO and reuse these validations across different DTOs.</p> <p>It is possible to have nested validators, just like DTOs.</p> Python<pre><code>class MyDto(BaseModel):\n    name: str\n\nclass MyComplexDto(BaseModel):\n    complex_name: str\n    my_dto: MyDto\n\nclass MyValidator(BaseValidator):\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        # Validation Code\n\nclass MyComplexValidator(BaseValidator):\n    my_dto: MyValidator\n\n    @validate('complex_name')\n    def validate_complex_name(value: str, _: Dict[str, Any]) -&gt; str:\n        # Validation Code\n</code></pre> <p>It doesn't matter if the field to be validated is a list or a dictionary; the configuration remains the same.</p> Python<pre><code>class MyDto(BaseModel):\n    name: str\n\nclass MyComplexDto(BaseModel):\n    complex_name: str\n    my_dto_list: List[MyDto]\n\nclass MyValidator(BaseValidator):\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        # Validation Code\n\nclass MyComplexValidator(BaseValidator):\n    my_dto_list: MyValidator\n\n    @validate('complex_name')\n    def validate_complex_name(value: str, _: Dict[str, Any]) -&gt; str:\n        # Validation Code\n</code></pre> <p>There is also the possibility of not validating the DTO at all and delegating this task to a manual process. To do this, <code>None</code> should be sent in the <code>body</code> property instead of the validator.</p> Python<pre><code>@app.controller()\nclass MyController(BaseController):\n    @app.post('/create', body={'validator': None})\n    async def create(self, request: MyDto):\n        # Code\n</code></pre> <p>In this case, the <code>request</code> parameter will contain the values sent via the <code>POST</code> method, but without validations.</p> <p>The DTO can be validated later using the following code:</p> Python<pre><code>@app.controller()\nclass MyController(BaseController):\n    @app.post('/create', body={'validator': None})\n    async def create(self, request: MyDto):\n        try:\n            await request.check()\n        except ModelError e:\n            print(e.errors)\n\n        # More Code\n</code></pre> <p>If you want to use a different validator than the DTO, it should be passed as a parameter to the <code>check</code> method.</p> Python<pre><code>try:\n    await request.check(MyValidator)\nexcept ModelError e:\n    print(e.errors)\n</code></pre> <p>It is possible to return these errors as they are generated by the exception when validating the model, or format them to match the format normally used when validations are performed automatically.</p> Python<pre><code>from cafeto.errors import format_errors\nfrom cafeto.responses import BadRequest\n\n@app.controller()\nclass MyController(BaseController):\n    @app.post('/create', body={'validator': None})\n    async def create(self, request: MyDto):\n        try:\n            await request.check()\n        except ModelError e:\n            errors = format_errors(e.errors)\n            return BadRequest(errors)\n\n        # More Code\n</code></pre>"},{"location":"websockets/","title":"WebSockets","text":""},{"location":"websockets/#introduction","title":"Introduction","text":"<p>WebSockets are a technology that allows real-time bidirectional communication between a client (such as a web browser) and a server. This is done through a single persistent socket connection, which reduces latency and improves efficiency in applications that need frequent updates, such as live chats, online games, or real-time dashboards.</p> <p>Cafeto uses the same WebSockets from Starlette for real-time communication and offers two ways to implement it.</p>"},{"location":"websockets/#traditional-method","title":"Traditional Method","text":"Python<pre><code>@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        await self.websocket.accept()\n        # Your code on connect here.\n\n        while True:\n            try:\n                # Your code on receive here.\n                data = await self.websocket.receive_json()\n\n                # Send message.\n                await self.websocket.send_json({'Hola': 'Mundo'})\n            except Exception as e:\n                # Your code on disconnect here.\n                break\n</code></pre> <p>In this case, the information is received as JSON without being assigned to a DTO, and the response is a JSON with the format:</p> JSON<pre><code>{\n    \"message\": \"Hi\",\n    \"user\": \"System\"\n}\n</code></pre>"},{"location":"websockets/#callback-method","title":"Callback Method","text":"Unified StyleClassic Style Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        async def on_connect():\n            pass # Your code on connect here.\n\n        async def on_disconnect():\n            pass # Your code on disconnect here.\n\n        async def on_receive(data: ChatRequestDto) -&gt; ChatResponseDto:\n            # Your code on receive here.\n            response = ChatResponseDto(message='Hi', user='System')\n\n            # Response message.\n            return Ok(response)\n\n        await self.websocket.accept_callback(\n            on_connect=on_connect,\n            on_disconnect=on_disconnect,\n            on_receive=on_receive\n        )\n</code></pre> Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import ModelWSResponse\n\n@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        async def on_connect():\n            pass # Your code on connect here.\n\n        async def on_disconnect():\n            pass # Your code on disconnect here.\n\n        async def on_receive(data: ChatRequestDto) -&gt; ChatResponseDto:\n            # Your code on receive here.\n            response = ChatResponseDto(message='Hi', user='System')\n\n            # Response message.\n            return ModelWSResponse(response)\n\n        await self.websocket.accept_callback(\n            on_connect=on_connect,\n            on_disconnect=on_disconnect,\n            on_receive=on_receive\n        )\n</code></pre> <p>Note: It is important to note that the response should not be made using <code>ModelResponse</code> but <code>ModelWSResponse</code>. For now, responses like JSONResponse, PlainTextResponse, and HTMLResponse are not available with WebSockets.</p> <p>It is also possible to do it this way:</p> Unified StyleClassic Style Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        await self.websocket.accept_callback(\n            on_receive=self.on_receive,\n            on_connect=self.on_connect,\n            on_disconnect=self.on_disconnect\n        )\n\n    async def on_connect(self):\n        pass # Your code on connect here.\n\n    async def on_disconnect(self) -&gt; None:\n        pass # Your code on disconnect here.\n\n    async def on_receive(self, data: ChatRequestDto) -&gt; ChatResponseDto:\n        # Your code on receive here.\n        response = ChatResponseDto(message='Hi', user='System')\n\n        # Response message.\n        return Ok(response)\n</code></pre> Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import ModelWSResponse\n\n@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        await self.websocket.accept_callback(\n            on_receive=self.on_receive,\n            on_connect=self.on_connect,\n            on_disconnect=self.on_disconnect\n        )\n\n    async def on_connect(self):\n        pass # Your code on connect here.\n\n    async def on_disconnect(self) -&gt; None:\n        pass # Your code on disconnect here.\n\n    async def on_receive(self, data: ChatRequestDto) -&gt; ChatResponseDto:\n        # Your code on receive here.\n        response = ChatResponseDto(message='Hi', user='System')\n\n        # Response message.\n        return ModelWSResponse(response)\n</code></pre> <p>In this method, messages arrive in a DTO, with all the validations and features that DTOs imply in HTTP actions.</p> <p>The response also changes, as WebSocket messages do not have a <code>statusCode</code> like traditional HTTP requests. The incoming message would have the following format:</p> JSON<pre><code>{\n    \"statusCode\": 200,\n    \"body\": {\n        \"message\": \"Hi\",\n        \"user\": \"System\"\n    }\n}\n</code></pre> <p>But if the DTO validations fail, the response could be:</p> JSON<pre><code>{\n    \"statusCode\": 400,\n    \"body\": {\n        \"errorList\": [\n            {\n                \"loc\": [\"message\"],\n                \"type\": \"missing\",\n                \"msg\": \"Field required\"\n            }\n        ]\n    }\n}\n</code></pre> <p>In this way, the response of HTTP requests can be emulated.</p> <p>Note: Only the <code>on_receive</code> callback is required; <code>on_connect</code> and <code>on_disconnect</code> are optional.</p>"},{"location":"dto/dto/","title":"DTO","text":""},{"location":"dto/dto/#introduction","title":"Introduction","text":"<p>A DTO (Data Transfer Object) is a design pattern used in software development to facilitate the transfer of data between different layers or components of an application. Its functionality focuses on three key aspects:</p> <ol> <li> <p>Obtaining data from the request: DTOs are responsible for receiving the data provided by the client in requests, encapsulating them in a structured and clear manner.</p> </li> <li> <p>Data validation and quality: Before the data is processed or stored, the DTO ensures that it meets validation requirements, such as correct data types, expected values, and possible constraints. This ensures the integrity and quality of the information within the application.</p> </li> <li> <p>Bridge between client and internal data: They act as intermediaries between client requests and the internal layers of the system, such as the business logic layer or the persistence layer. This decouples the internal structures of the system from external interactions, promoting a more flexible and maintainable design.</p> </li> </ol> <p>In summary, a DTO not only organizes incoming data but also ensures that it is consistent and serves the role of efficiently connecting the client with internal processes.</p> <p>Cafeto uses Pydantic as the library for creating DTOs.</p>"},{"location":"dto/dto/#usage","title":"Usage","text":"Python<pre><code>from datetime import date\n\nfrom cafeto.models import BaseModel\n\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str\n    confirm_password: str\n    name: str\n    birth_date: date\n\n\nclass CreateUserResponseDto(BaseModel):\n    id: int\n    username: str\n    name: str\n    birth_date: date\n</code></pre> <p>Here, two DTOs are defined, one for data input (Request) and one for data output (Response).</p> <p>Note: The <code>BaseModel</code> class comes from <code>cafeto.models</code>, which inherits from <code>BaseModel</code> of Pydantic, as some necessary functions have been added.</p> <p>A good strategy is to use a base class to share fields related to the <code>request</code> and <code>response</code>. This way, the classes that inherit from it can reuse these fields, avoiding the need to define them multiple times.</p> Python<pre><code>from datetime import date\n\nfrom cafeto.models import BaseModel\n\n\nclass BaseUserDto(BaseModel):\n    username: str\n    name: str\n    birth_date: date\n\n\nclass CreateUserRequestDto(BaseUserDto):\n    password: str\n    confirm_password: str\n\n\nclass CreateUserResponseDto(BaseUserDto):\n    id: int\n</code></pre> <p>It is possible to achieve a robust enough configuration to organize DTOs more efficiently, ensuring clarity and order in their structure.</p> Python<pre><code>from datetime import date\n\nfrom cafeto.models import BaseModel\n\n\nclass BaseUserDto(BaseModel):\n    username: str\n    name: str\n    birth_date: date\n\n\nclass BaseUserRequestDto(BaseUserDto):\n    password: str\n    confirm_password: str\n\n\nclass BaseUserResponseDto(BaseUserDto):\n    id: int\n\n\nclass CreateUserRequestDto(BaseUserRequestDto):\n    ...\n\n\nclass UpdateUserRequestDto(BaseUserRequestDto):\n    old_password: str\n\n\nclass CreateUserResponseDto(BaseUserResponseDto):\n    ...\n\n\nclass UpdateUserResponseDto(BaseUserResponseDto):\n    ...\n</code></pre>"},{"location":"dto/generic_response/","title":"GenericResponseDto","text":""},{"location":"dto/generic_response/#introduction","title":"Introduction","text":"<p>This DTO is used to send responses containing a generic value.</p> Python<pre><code>from cafeto.dtos import GenericResponseDto\n\n@app.controller()\nclass HomeController(BaseController):\n    @app.get('/home')\n    async def home(self) -&gt; GenericResponseDto[str]:\n        # Response Generic str\n        return Ok(GenericResponseDto(data='Hello World!'))\n</code></pre> Python<pre><code>from cafeto.dtos import GenericResponseDto\n\n@app.controller()\nclass HomeController(BaseController):\n    @app.get('/home')\n    async def home(self) -&gt; GenericResponseDto[Dict[str, str]]:\n        # Response Generic Dict\n        return Ok(GenericResponseDto(data={'Hello': 'World!'}))\n</code></pre>"},{"location":"other/alternatives/","title":"Alternatives","text":"<p>Cafeto is a lightweight yet powerful framework, built on top of Starlette, specifically designed to simplify and accelerate the development of modern APIs. It provides an organized approach to API creation and integrates robust support for the three types of dependency injection: Singleton, Scoped, and Transient.</p> <p>Additionally, Cafeto uses DTOs to manage, validate, and structure the data sent and received on the server. It also includes integration with OpenAPI and Swagger, facilitating API documentation and testing.</p> <p>Although Cafeto is a robust tool, there are other options such as Starlette, a lightweight and high-performance framework that serves as the foundation for other frameworks like FastAPI and Cafeto. There's also FastAPI, known for its speed and automatic data validation; Django, ideal for large-scale applications with its \"all-in-one\" approach; and Flask, a flexible microframework for simpler projects. Each tool has its strengths, but Cafeto stands out by combining efficiency, structure, and organization in a single package.</p>"},{"location":"other/coming_soon/","title":"Coming Soon","text":""},{"location":"other/coming_soon/#introduction","title":"Introduction","text":"<p>Although the system is already very effective and offers a solid set of features, continuous work is being done to improve it. The goal is to keep implementing new enhancements and functionalities to optimize the user experience. Here are some of the exciting updates to expect:</p>"},{"location":"other/coming_soon/#dependency-injection-from-the-controller-constructor","title":"Dependency Injection from the Controller Constructor","text":"<p>Allow actions that share dependencies not to need to define them in each action of the same controller.</p> <p>Example:</p> Python<pre><code>@app.controller()\nclass UserController(BaseController):\n    def __init__(self, my_dependency: MyDependency):\n        self.my_dependency = my_dependency\n\n    @app.get('/get')\n    async def get(self) -&gt; UserResponseDto:\n        await self.my_dependency.do_something()\n\n    @app.get('/get-all')\n    async def get_all(self) -&gt; UserResponseDto:\n        await self.my_dependency.do_something()\n</code></pre>"},{"location":"other/coming_soon/#improvements-to-event-functionality","title":"Improvements to Event Functionality","text":"<p>Enhance the event system to make it more versatile and robust by incorporating features such as:</p> <ul> <li> <p>Allowing events to generate responses, enabling more dynamic interactions.</p> </li> <li> <p>Implementing the ability for events to raise exceptions, with support for capturing and intercepting them as needed.</p> </li> <li> <p>Ensuring efficient error handling and controlled execution flow within events.</p> </li> </ul>"},{"location":"other/coming_soon/#addition-of-new-events","title":"Addition of New Events","text":"<p>Expand the current system by introducing new events. Some initial ideas include:</p> <ul> <li>OnModeValidationFail: An event triggered when mode validation fails, allowing for specific and customized handling of this scenario.</li> </ul>"},{"location":"other/coming_soon/#enhanced-validation-system","title":"Enhanced Validation System","text":"<p>We will implement a more advanced system for data validation.</p> <p>The general idea is to create a validation system that can be used outside of DTOs and offer an easy way to return errors if they exist.</p>"},{"location":"other/coming_soon/#objectives","title":"Objectives","text":"<ul> <li>Flexibility: Allow the use of validations in different contexts beyond DTOs.</li> <li>Ease of Use: Provide a simple interface for defining and managing validation rules.</li> <li>Efficiency: Ensure that validations are performed quickly and effectively.</li> </ul>"},{"location":"other/coming_soon/#cli-implementation","title":"CLI Implementation","text":"<p>We will develop a command-line interface (CLI) for project creation.</p>"},{"location":"other/coming_soon/#examples","title":"Examples","text":"<ol> <li> <p>Create a new project: Bash<pre><code>cafeto new project-name\n</code></pre></p> </li> <li> <p>Generate a controller: Bash<pre><code>cafeto create controller user\n</code></pre></p> </li> </ol>"},{"location":"other/coming_soon/#objectives_1","title":"Objectives","text":"<ul> <li>Ease of Use: Provide simple and intuitive commands for project creation and management.</li> <li>Efficiency: Reduce the time and effort required to initialize and configure projects.</li> <li>Flexibility: Allow the CLI to be extended and customized according to user needs.</li> </ul>"},{"location":"other/coming_soon/#development-templates","title":"Development Templates","text":"<p>We will equip the system with the ability to start projects with predefined templates, avoiding starting from scratch for each new project.</p>"},{"location":"other/coming_soon/#default-user-and-permissions-system","title":"Default User and Permissions System","text":"<p>We will develop a system where user and permissions management is pre-designed, saving time in each new project.</p>"},{"location":"other/coming_soon/#documentation-improvements","title":"Documentation Improvements","text":"<p>We are working on improving the documentation, adding more examples, and providing more details about the system's features.</p>"},{"location":"other/coming_soon/#increase-parameter-support","title":"Increase Parameter Support","text":"<p>Add the ability to support more complex data types such as lists, dates, etc.</p> Python<pre><code>from datetime import date\nfrom typing import List\n\nfrom cafeto.mvc import BaseController\n\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/view-filter/{ids}', query=['date'])\n    async def view_filter(self, ids: List[int], date: date) -&gt; None:\n        pass\n</code></pre>"},{"location":"other/coming_soon/#improve-openapi-integration","title":"Improve OpenApi Integration","text":"<p>We will provide more support for OpenApi features to enhance integration.</p>"},{"location":"other/coming_soon/#integration-with-prometheus-and-grafana","title":"Integration with Prometheus and Grafana","text":"<p>Using the template system and Docker, the ability to create logs of API events to generate system metrics will be implemented. This integration will allow developers and system administrators to monitor the performance and health of their applications more effectively.</p>"},{"location":"other/coming_soon/#objectives_2","title":"Objectives","text":"<ul> <li>Real-time Monitoring: Allow real-time observation of system metrics, such as CPU usage, memory, request latency, error rates, among others.</li> <li>Proactive Alerts: Configure alerts to notify administrators when certain critical thresholds are reached, allowing for a quick response to potential issues.</li> <li>Historical Analysis: Store historical data to analyze trends and usage patterns over time, aiding in informed decision-making about infrastructure and application performance.</li> <li>Data Visualization: Use Grafana to create custom dashboards that clearly and comprehensively visualize the collected metrics.</li> </ul>"},{"location":"other/coming_soon/#custom-response-styles","title":"Custom Response Styles","text":"<p>Allow choosing between different response styles for services, not limited to JSON. The idea is to switch between <code>JSON</code>, <code>XML</code>, and <code>YML</code>.</p> Unified styleClassic style Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/view/{id}')\n    async def view(self, id: int) -&gt; UserResponseDto:\n        user = &lt;some_user_service&gt;.get(id)\n        return Ok(UserResponseDto(**user), style='XML')\n</code></pre> Python<pre><code>from cafeto.responses import ModelResponse\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/view/{id}')\n    async def view(self, id: int) -&gt; UserResponseDto:\n        user = &lt;some_user_service&gt;.get(id)\n        return ModelResponse(UserResponseDto(**user), style='XML')\n</code></pre> <p>Info</p> <p>styles</p> <ul> <li>style='JSON' (default)</li> <li>style='XML'</li> <li>style='YML'</li> </ul>"},{"location":"other/coming_soon/#performance-improvements","title":"Performance Improvements","text":"<p>We will optimize the system to ensure faster and more efficient performance.</p>"},{"location":"other/coming_soon/#creating-an-api-prefix","title":"Creating an API Prefix","text":"<p>The functionality to add a prefix to the URLs of all API endpoints is proposed to maintain a more organized and consistent structure.</p> <p>For example, using the following command:</p> Python<pre><code>app.map_controllers(prefix='my-api')\n</code></pre> <p>This will ensure that all service routes begin with the specified prefix. The resulting URLs would look like this:</p> Bash<pre><code>http://127.0.0.1:8000/my-api/my-controller/my-action\n</code></pre> <p>This approach simplifies the grouping of endpoints under a shared context and improves the readability and management of API routes.</p>"},{"location":"other/coming_soon/#api-versioning-system","title":"API Versioning System","text":"<p>Implement a versioning system for APIs that will allow developers to manage and maintain multiple versions of their APIs efficiently.</p>"},{"location":"other/coming_soon/#objectives_3","title":"Objectives","text":"<ul> <li>Compatibility: Ensure that previous versions of the APIs continue to function while new versions are being developed.</li> <li>Ease of Use: Provide clear tools and documentation for version management.</li> <li>Flexibility: Allow developers to choose which versions of the APIs they want to maintain and which to deprecate.</li> </ul>"},{"location":"other/coming_soon/#example","title":"Example","text":"Python<pre><code># --- main.py ---\napp.map_controllers(version='v2')\n\n# --- user_v1.py ---\n@app.controller(version='v1')\nclass UserController(BaseController):\n    @app.get('/user')\n    async def get_user(self) -&gt; UserResponseDto:\n        pass\n\n# --- user_v2.py ---\n@app.controller(version='v2') #(1)\nclass UserController(BaseController):\n    @app.get('/user')\n    async def get_user(self) -&gt; UserResponseDto:\n        pass\n</code></pre> <ol> <li> <p>Info</p> Other way Python<pre><code>@app.controller() # 'v2' by default\n</code></pre> </li> </ol>"},{"location":"other/coming_soon/#adaptability-and-continuous-evolution","title":"Adaptability and Continuous Evolution","text":"<p>We are committed to continuous improvement and adaptation to technological advancements. The project is constantly evolving, observing trends and advancements in the software development field to implement best practices and the latest technologies.</p> <p>The goal is to ensure that the system remains up-to-date and relevant, incorporating new features and optimizations that benefit users. Suggestions are welcome, and we are always open to feedback to keep improving.</p>"},{"location":"other/coming_soon/#example_1","title":"Example","text":"<ul> <li>Integration of New Technologies: Adopt new tools and frameworks that emerge in the market.</li> <li>Regular Updates: Implement continuous improvements and security patches.</li> <li>User Feedback: Actively listen to user needs and suggestions to adapt to their requirements.</li> </ul>"},{"location":"other/license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 [2025] [Jonathan Espinal]</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"services/context/","title":"AContextService","text":""},{"location":"services/context/#introduction","title":"Introduction","text":"<p>It is a <code>scoped</code> type service that can be injected to obtain information about the current request context. The information contained in this service includes:</p> <ul> <li><code>path: str</code>: The path to which the action was reached.</li> <li><code>method: str</code>: The current method (<code>POST</code>, <code>GET</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>).</li> <li><code>headers: Dict[str, Any]</code>: The request headers.</li> <li><code>query: Dict[str, Any]</code>: The query string parameters.</li> <li><code>controller_name: str</code>: The name of the controller to which the request was directed.</li> <li><code>action_name: str</code>: The name of the action to which the request was directed.</li> <li><code>request_model: BaseModel</code>: The DTO with the request body, only applicable to (<code>POST</code>, <code>PUT</code>, <code>PATCH</code>) methods.</li> </ul> <p>To use it, simply inject it like any other service.</p> Python<pre><code>from cafeto.services import AContextService\n\nclass MyService:\n    def __init__(self, context_service: AContextService) -&gt; None:\n        self.context_service = context_service\n</code></pre>"},{"location":"services/default_services/","title":"Default Services","text":""},{"location":"services/default_services/#introduction","title":"Introduction","text":"<p>Cafeto includes some pre-designed services that can be used through dependency injection.</p> <p>To use these services, you need to invoke them.</p> Python<pre><code>from cafeto import App\n\napp: App = App()\napp.use_default_services()\n</code></pre>"},{"location":"es/#introduccion","title":"Introducci\u00f3n","text":"<p>Cafeto es un framework liviano pero poderoso dise\u00f1ado como una capa superior sobre Starlette, enfocado en simplificar y acelerar el desarrollo de APIs modernas. Aprovecha las s\u00f3lidas bases de Starlette, ofreciendo herramientas adicionales para un desarrollo m\u00e1s eficiente y organizado.</p> <p> English |  Espa\u00f1ol</p>"},{"location":"es/#requisitos","title":"Requisitos","text":"<p>Este proyecto requiere Python 3.10 o una versi\u00f3n superior.</p>"},{"location":"es/#instalacion","title":"Instalaci\u00f3n","text":"Bash<pre><code>pip install cafeto\n</code></pre>"},{"location":"es/#proyecto","title":"Proyecto","text":"<p>Cafeto</p>"},{"location":"es/#documentacian","title":"Documentaci\u00e1n","text":"<p>Cafeto docs</p>"},{"location":"es/#descripcion","title":"Descripci\u00f3n","text":"<p>Cafeto es un framework dise\u00f1ado para crear APIs de manera eficiente y organizada, inspirado en otros frameworks y enriquecido con ideas innovadoras.</p> <ul> <li>Ofrece un poderoso sistema de inyecci\u00f3n de dependencias, soportando los tres ciclos de vida: <code>Singleton</code>, <code>Scoped</code> y <code>Transient</code>.</li> <li>Facilita la recepci\u00f3n y env\u00edo de informaci\u00f3n mediante DTOs (Data Transfer Objects), que tambi\u00e9n se utilizan para la validaci\u00f3n y gesti\u00f3n de los datos que interact\u00faan con el servidor.</li> <li>Cuenta con un sistema de eventos que ampl\u00eda las capacidades del framework, permitiendo una mayor personalizaci\u00f3n y flexibilidad.</li> <li>Proporciona integraci\u00f3n con herramientas como OpenAPI y Swagger, para la generaci\u00f3n de documentaci\u00f3n interactiva y pruebas de las APIs.</li> </ul> <p>Con Cafeto, los desarrolladores pueden construir APIs robustas y escalables con facilidad, aprovechando caracter\u00edsticas modernas y un enfoque bien estructurado.</p>"},{"location":"es/#starlette","title":"Starlette","text":"<p>Starlette, la base de Cafeto, es ampliamente reconocido como uno de los frameworks m\u00e1s destacados para la construcci\u00f3n de aplicaciones web asincr\u00f3nicas en Python. Su dise\u00f1o minimalista, combinado con un rendimiento sobresaliente, lo hace ideal para desarrolladores que buscan flexibilidad y potencia. Starlette no solo ofrece capacidades de routing, middleware y soporte para WebSockets, sino que tambi\u00e9n integra herramientas avanzadas para manejo de tareas as\u00edncronas y pruebas, posicion\u00e1ndose como un est\u00e1ndar dorado en el desarrollo web moderno.</p> <p>Aprovechando el poder de Starlette, Cafeto lleva esta experiencia al siguiente nivel, proporcionando una soluci\u00f3n a\u00fan m\u00e1s optimizada y amigable para construir APIs. Juntos, Cafeto y Starlette forman un d\u00fao perfecto para cualquier desarrollador que busque velocidad, simplicidad y excelencia t\u00e9cnica.</p>"},{"location":"es/#objetivo-principal","title":"Objetivo Principal","text":"<p>Crear una experiencia de desarrollo m\u00e1s fluida para APIs, proporcionando abstracciones intuitivas, configuraciones predeterminadas inteligentes y compatibilidad con est\u00e1ndares modernos.</p>"},{"location":"es/#ejemplo","title":"Ejemplo","text":"Python<pre><code>import uvicorn\n\nfrom cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\nfrom cafeto.models import BaseModel\n\n\napp: App = App()\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str\n\n\nclass CreateUserResponseDto(BaseModel):\n    id: int\n    username: str\n\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, data: CreateUserRequestDto) -&gt; CreateUserResponseDto:\n        user = {'id': 1, 'username': data.username}\n        return Ok(CreateUserResponseDto(**user))\n\napp.map_controllers()\n\nif __name__ == \"__main__\": #(1)\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000, reload=True)\n</code></pre> <ol> <li>Tambi\u00e9n se puede ejecutar por comando: Bash<pre><code>uvicorn main:app --host 0.0.0.0 --port 8000 --reload\n</code></pre></li> </ol> <p>Este ejemplo muestra c\u00f3mo definir un controlador y dos DTOs (uno para la solicitud y otro para la respuesta), y c\u00f3mo configurar una ruta para crear un usuario.</p> <p>La clase <code>App</code> hereda de la clase <code>Starlette</code>, lo que implica que las propiedades de Starlette tambi\u00e9n est\u00e1n disponibles en la clase App. Un ejemplo de estas propiedades son los <code>Middleware</code>. Sin embargo, existe una configuraci\u00f3n adicional llamada <code>CafetoConfig</code>, la cual se explicar\u00e1 m\u00e1s adelante.</p> Python<pre><code>from cafeto.middleware import CORSMiddleware\n\nmiddleware = [\n    Middleware(CORSMiddleware, allow_origins=['*'])\n]\n\napp: App = App(debug=True, middleware=middleware)\n</code></pre>"},{"location":"es/#conclusion","title":"Conclusi\u00f3n","text":"<p>Cafeto es una herramienta poderosa que facilita la creaci\u00f3n de APIs en Python. Con soporte para inyecci\u00f3n de dependencias, DTOs y documentaci\u00f3n autom\u00e1tica, es una excelente opci\u00f3n para desarrolladores que buscan una soluci\u00f3n simple pero profesional para sus proyectos de API.</p>"},{"location":"es/access_control/","title":"Control de Acceso","text":""},{"location":"es/access_control/#introduccion","title":"Introducci\u00f3n","text":"<p>El control de acceso a un API es crucial para asegurar que solo usuarios autorizados puedan interactuar con los recursos y datos del sistema. Cafeto usa el mismo tipo de decorador de Starlette. De esta forma se permite especificar qu\u00e9 usuarios tienen permiso para ejecutar ciertas funciones, protegiendo la API de accesos no autorizados y garantizando la seguridad y privacidad de la informaci\u00f3n.</p>"},{"location":"es/access_control/#uso","title":"Uso","text":"Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\napp: App = App()\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/view')\n    @app.requires(['admin'])\n    async def view(self) -&gt; str:\n        return Ok('Hello World!')\n</code></pre> <p><code>@app.requires</code> funciona de la misma manera que <code>@requires</code> de Starlette.</p>"},{"location":"es/api/","title":"API","text":"<p>Pr\u00f3ximamente </p>"},{"location":"es/controllers_and_actions/","title":"Controladores y acciones","text":""},{"location":"es/controllers_and_actions/#introduccion","title":"Introducci\u00f3n","text":"<p>Los controladores en una aplicaci\u00f3n web son responsables de manejar las solicitudes del usuario, procesar datos y devolver respuestas adecuadas. Son los intermediarios entre el modelo y la vista.</p> <p>Las acciones son m\u00e9todos dentro de un controlador que manejan solicitudes espec\u00edficas, como mostrar una p\u00e1gina, guardar datos o realizar operaciones particulares.</p> <p>En resumen, los controladores organizan la l\u00f3gica de la aplicaci\u00f3n y las acciones ejecutan tareas espec\u00edficas en respuesta a las solicitudes del usuario.</p>"},{"location":"es/controllers_and_actions/#uso","title":"Uso","text":"Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\napp: App = App()\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, data: CreateUserRequestDto) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.create(data) #(1)\n        return Ok(CreateUserResponseDto(**user))\n\napp.map_controllers()\n</code></pre> <ol> <li> <p>Warning</p>    Servicio simulado para el ejemplo. </li> </ol> <p>Este API se puede consumir como:</p> Bash<pre><code>curl -X POST http://127.0.0.1:8000/user/create \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n           \"username\": \"superbad\",\n           \"password\": \"01-47-87441\",\n           \"confirm_password\": \"01-47-87441\",\n           \"name\": \"McLovin\",\n           \"birth_date\": \"1998-06-18\"\n         }'\n</code></pre> <p>Esto es lo m\u00ednimo requerido para la creaci\u00f3n de un API. Los datos llegar\u00e1n a la acci\u00f3n <code>create</code> del controlador <code>UserController</code> por el m\u00e9todo <code>POST</code> y se almacenar\u00e1n en el objeto <code>data</code>, que es del tipo <code>CreateUserRequestDto</code>. Finalmente, la respuesta ser\u00e1 un objeto tipo <code>CreateUserResponseDto</code>.</p> <p><code>ModelResponse</code> ser\u00e1 el encargado de devolver los datos de todos aquellos objetos (DTO) que hereden de <code>BaseModel</code>.</p> <p>NOTA: Es importante tipar el dato de entrada para que la asignaci\u00f3n de los datos sea correcta.</p> <p>NOTA: Para indicar a Cafeto que la aplicaci\u00f3n debe usar las acciones de los controladores, se debe usar: <code>app.map_controllers()</code>.</p> <p>De igual manera, se puede usar un objeto <code>JSONResponse</code> tradicional de Starlette para la respuesta.</p> Python<pre><code>return JSONResponse({\"username\": \"jondoe\", ...})\n</code></pre> <p>Para tener un mejor control, se recomienda usar los DTO siempre que se pueda. Tambi\u00e9n es \u00fatil para ver la documentaci\u00f3n y probar los APIs desde Swagger.</p> <p>Los m\u00e9todos disponibles son:</p> <ul> <li>@app.post (POST)</li> <li>@app.put (PUT)</li> <li>@app.patch (PATCH)</li> <li>@app.get (GET)</li> <li>@app.delete (DELETE)</li> <li>@app.options (OPTIONS)</li> </ul> <p>Nota: Solo los m\u00e9todos <code>POST</code> y <code>PUT</code> pueden recibir datos como par\u00e1metro de entrada, aunque no es obligatorio.</p> Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/activate')\n    async def activate(self) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.get() #(1)\n        return Ok(CreateUserResponseDto(**user))\n</code></pre> <ol> <li> <p>Warning</p>    Servicio simulado para el ejemplo. </li> </ol> <p>Nota: Si el decorador <code>@app.controller</code> no tiene un par\u00e1metro, se usar\u00e1 el nombre de la clase sin la palabra \"Controller\".</p> Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller() # No param\nclass UserController(BaseController):\n    @app.post('/activate')\n    async def activate(self) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.get() #(1)\n        return Ok(CreateUserResponseDto(**user))\n</code></pre> <ol> <li> <p>Warning</p>    Servicio simulado para el ejemplo. </li> </ol> <p>En este caso, la URL ser\u00e1: http://127.0.0.1:8000/user/activate</p>"},{"location":"es/dependency_injection/","title":"Inyecci\u00f3n de dependencias","text":""},{"location":"es/dependency_injection/#introduccion","title":"Introducci\u00f3n","text":"<p>La inyecci\u00f3n de dependencias es un patr\u00f3n de dise\u00f1o que permite a los objetos recibir sus dependencias de manera externa, en lugar de crearlas por s\u00ed mismos. Este enfoque facilita la gesti\u00f3n de componentes y promueve un c\u00f3digo m\u00e1s modular y mantenible.</p>"},{"location":"es/dependency_injection/#para-que-sirve","title":"Para qu\u00e9 sirve","text":"<ul> <li>Simplifica las pruebas unitarias.</li> <li>Facilita el mantenimiento y la escalabilidad.</li> <li>Reduce el acoplamiento entre componentes.</li> </ul>"},{"location":"es/dependency_injection/#importancia","title":"Importancia","text":"<ul> <li>Mejora la flexibilidad del c\u00f3digo.</li> <li>Permite una mayor reutilizaci\u00f3n de componentes.</li> <li>Facilita la inyecci\u00f3n de diferentes implementaciones o configuraciones en tiempo de ejecuci\u00f3n.</li> </ul>"},{"location":"es/dependency_injection/#tipos","title":"Tipos","text":"<p>En el contexto de la inyecci\u00f3n de dependencias, existen tres tipos principales de dependencias: <code>Singleton</code>, <code>Transient</code> y <code>Scoped</code>. Cada una se diferencia en c\u00f3mo y cu\u00e1ndo se crean las instancias de los servicios a lo largo del ciclo de vida de la aplicaci\u00f3n. Estas distintas formas de gestionar las dependencias permiten un mejor control sobre el uso de recursos, la eficiencia y la coherencia del estado en diferentes contextos de la aplicaci\u00f3n.</p>"},{"location":"es/dependency_injection/#singleton","title":"Singleton","text":"<p>Descripci\u00f3n: Una \u00fanica instancia de la dependencia es creada y compartida durante toda la vida de la aplicaci\u00f3n.</p> <p>Casos de Uso: Utilizado para servicios de configuraci\u00f3n, conexiones de base de datos o cualquier recurso compartido.</p>"},{"location":"es/dependency_injection/#scoped","title":"Scoped","text":"<p>Descripci\u00f3n: Una \u00fanica instancia de la dependencia es creada y compartida durante el ciclo de vida de una solicitud (request).</p> <p>Casos de Uso: Adecuado para servicios que mantienen estado y necesitan ser consistentes durante una solicitud HTTP.</p>"},{"location":"es/dependency_injection/#transient","title":"Transient","text":"<p>Descripci\u00f3n: Una nueva instancia de la dependencia es creada cada vez que se solicita.</p> <p>Casos de Uso: Ideal para servicios ligeros que no mantienen estado y son de corta duraci\u00f3n.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant Service\n    participant Singleton_Instance\n    participant Scoped_Instance\n    participant Transient_Instance\n\n    Client-&gt;&gt;Server: Solicitud\n    Server-&gt;&gt;Service: Llamar servicio\n\n    Service-&gt;&gt;Singleton_Instance: Verificar/Crear instancia\n    Singleton_Instance--&gt;&gt;Service: Proveer instancia\n    Note left of Singleton_Instance: La instancia no se volver\u00e1&lt;br&gt;a crear nunca m\u00e1s.\n\n    Service-&gt;&gt;Scoped_Instance: Verificar / Crear instancia (Por solicitud)\n    Scoped_Instance--&gt;&gt;Service: Proveer instancia\n    Note left of Scoped_Instance: La instancia no se vuelve&lt;br&gt;a crear durante esta solicitud&lt;br&gt;pero crear\u00e1 una nueva en la&lt;br&gt;siguiente solicitud.\n\n    Service-&gt;&gt;Transient_Instance: Crear nueva instancia (Cada vez)\n    Transient_Instance--&gt;&gt;Service: Proveer instancia\n    Note left of Transient_Instance: La instancia se volver\u00e1 a&lt;br&gt;crear cada vez que se inyecte&lt;br&gt;en esta solicitud y en las&lt;br&gt;siguientes.\n\n    Service--&gt;&gt;Server: Retornar instancia\n    Server--&gt;&gt;Client: Respuesta</code></pre>"},{"location":"es/dependency_injection/#integracion","title":"Integraci\u00f3n","text":"<p>Existen tres m\u00e9todos para almacenar las dependencias seg\u00fan sea el caso: <code>add_singleton</code>, <code>add_scoped</code>, <code>add_transient</code>.</p> Python<pre><code>from cafeto import App\n\napp: App = App()\n\napp.add_singleton()\napp.add_scoped()\napp.add_transient()\n</code></pre> <p>En el contexto de la inyecci\u00f3n de dependencias, existen dos enfoques principales: basadas en <code>interfaces</code> o en <code>clases</code>. A continuaci\u00f3n, se explica cada uno y se detalla cu\u00e1ndo es m\u00e1s apropiado utilizar uno u otro.</p>"},{"location":"es/dependency_injection/#inyeccion-de-dependencias-basada-en-interfaces","title":"Inyecci\u00f3n de Dependencias Basada en Interfaces","text":"<p>Este enfoque implica definir una interfaz y asociarla con una clase concreta. Aunque Python no tiene interfaces como tal, es posible utilizar clases abstractas con el m\u00f3dulo <code>ABC</code> (Abstract Base Classes) para lograr una funcionalidad similar.</p> <p>Cu\u00e1ndo Usar:</p> <ul> <li>Flexibilidad: Permite cambiar f\u00e1cilmente la implementaci\u00f3n de la interfaz sin modificar el c\u00f3digo dependiente.</li> <li>Pruebas Unitarias: Facilita la creaci\u00f3n de mock objects para pruebas.</li> <li>Desacoplamiento: Reduce la dependencia directa entre componentes, mejorando la mantenibilidad del c\u00f3digo.</li> </ul> Python<pre><code>from abc import ABC\nfrom typing import Optional\n\nfrom cafeto import App\n\nclass AUserService(ABC):\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        ...\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        ...\n\nclass UserService(AUserService):\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        try:\n            await &lt;some_database_connection&gt;.insert('users', user) #(1)\n            return True\n        except:\n            return False\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        try:\n            user = await &lt;some_database_connection&gt;.select('users', id) #(2)\n            return UserResponseDto(user)\n        except:\n            return None\n\napp: App = App()\napp.add_scoped(AUserService, UserService) # Store service\n</code></pre> <ol> <li> <p>Warning</p>    Servicio simulado para el ejemplo. </li> <li> <p>Warning</p> <p>Servicio simulado para el ejemplo.</p> </li> </ol> <p>En el ejemplo anterior, se almacena la dependencia utilizando <code>AUserService</code> y <code>UserService</code>.</p>"},{"location":"es/dependency_injection/#por-que-es-esto-util","title":"\u00bfPor qu\u00e9 es esto \u00fatil?","text":"<p>Supongamos que, m\u00e1s adelante en el proyecto, se requiere no almacenar los usuarios en una base de datos, sino enviarlos a un microservicio. En ese caso, podemos crear otra clase llamada <code>UserServiceToService</code> con los mismos m\u00e9todos, sin necesidad de eliminar la clase actual <code>UserService</code>. Esto implica que no ser\u00e1 necesario cambiar, en cada endpoint, la llamada al servicio. Adem\u00e1s, nos permite conservar la clase original <code>UserService</code> en caso de llegar a ser requerida en el futuro.</p> <p>Este enfoque permite:</p> <ul> <li>Flexibilidad: Cambiar la implementaci\u00f3n de los servicios sin afectar el c\u00f3digo dependiente.</li> <li>Desacoplamiento: Mantener una separaci\u00f3n clara entre la definici\u00f3n de la interfaz y su implementaci\u00f3n, lo que mejora la mantenibilidad.</li> <li>Reutilizaci\u00f3n: Permitir que m\u00faltiples implementaciones coexistan y se utilicen en diferentes contextos seg\u00fan sea necesario.</li> </ul> <p>Ahora es importante saber c\u00f3mo inyectar la dependencia, y para esto es indispensable no usar <code>UserService</code> directamente, sino <code>AUserService</code>, ya que es a trav\u00e9s de esta interfaz como se llegar\u00e1 a <code>UserService</code>. Esto garantiza que el sistema pueda cambiar f\u00e1cilmente la implementaci\u00f3n de <code>AUserService</code> sin afectar el c\u00f3digo dependiente, permitiendo una mayor flexibilidad y desacoplamiento en tu aplicaci\u00f3n.</p>"},{"location":"es/dependency_injection/#inyeccion-de-dependencias-basada-en-clases","title":"Inyecci\u00f3n de Dependencias Basada en Clases","text":"<p>Este enfoque implica inyectar directamente una clase concreta sin utilizar interfaces o clases abstractas. Es menos flexible pero puede ser adecuado para implementaciones simples y directas.</p> <p>Cu\u00e1ndo Usar:</p> <ul> <li>Simplicidad: Adecuado para proyectos peque\u00f1os o cuando no se espera que la implementaci\u00f3n cambie.</li> <li>Menos Sobrecarga: No necesitas definir clases abstractas o interfaces, lo que simplifica el desarrollo.</li> </ul> Python<pre><code>class CacheUserService:\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        try:\n            await &lt;some_cache_connection&gt;.insert('users', user) #(1)\n            return True\n        except:\n            return False\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        try:\n            user = await &lt;some_cache_connection&gt;.select('users', id) #(2)\n            return UserResponseDto(user)\n        except:\n            return None\n\napp: App = App()\napp.add_scoped(CacheUserService) # Store service\n</code></pre> <ol> <li> <p>Warning</p>    Servicio simulado para el ejemplo. </li> <li> <p>Warning</p> <p>Servicio simulado para el ejemplo.</p> </li> </ol> <p>En este caso, a diferencia del ejemplo anterior, se utiliza \u00fanicamente <code>CacheUserService</code>. Esto se debe a que, durante la definici\u00f3n del proyecto, se estim\u00f3 que las probabilidades de que este servicio cambie son casi nulas. Por lo tanto, este enfoque se consider\u00f3 el m\u00e1s adecuado para este caso particular.</p> <p>Para inyectar esta dependencia, es necesario usar <code>CacheUserService</code> directamente, ya que no se cuenta con una interfaz o clase abstracta asociada a esta implementaci\u00f3n.</p>"},{"location":"es/dependency_injection/#comparacion-y-uso-en-python","title":"Comparaci\u00f3n y Uso en Python","text":"<p>En Python, dado que no existen interfaces formales como en otros lenguajes, es posible utilizar clases abstractas del m\u00f3dulo ABC para lograr una funcionalidad similar. Aqu\u00ed tienes una comparaci\u00f3n general:</p> <p>Inyecci\u00f3n Basada en Interfaces (ABC):</p> <ul> <li>Pros: Flexibilidad, facilidad para pruebas unitarias, menor acoplamiento.</li> <li>Contras: Puede agregar complejidad adicional.</li> </ul> <p>Inyecci\u00f3n Basada en Clases:</p> <ul> <li>Pros: Simplicidad, desarrollo m\u00e1s r\u00e1pido.</li> <li>Contras: Menor flexibilidad, m\u00e1s dif\u00edcil de cambiar o probar.</li> </ul>"},{"location":"es/dependency_injection/#generador-generator","title":"Generador (Generator)","text":"<p>El generador es otro par\u00e1metro (Opcional) al registrar una dependencia. Su funci\u00f3n es brindar mayor control sobre c\u00f3mo se crea y almacena dicha dependencia. Es un <code>Callable</code> que recibe como par\u00e1metro los datos necesarios para la dependencia registrada (<code>**data</code>).</p> Python<pre><code>class AMyService:\n    def __init__(self, other_service: AOtherService, extra_param: str) -&gt; None:\n        ...\n\nclass MyService:\n    def __init__(self, other_service: AOtherService, extra_param: str) -&gt; None:\n        self.other_service: AOtherService = other_service\n        self.extra_param: str = extra_param\n\ndef my_service_generator(**params):\n    params['extra_param'] = 'Hello World!'\n    return MyService(**params)\n\napp.add_scoped(AMyService, MyService, my_service_generator)\n</code></pre> <p>La clase abstracta no es obligatoria, por lo que el c\u00f3digo tambi\u00e9n podr\u00eda simplificarse de esta forma:</p> Python<pre><code>class MyService:\n    def __init__(self, other_service: AOtherService, extra_param: str) -&gt; None:\n        self.other_service: AOtherService = other_service\n        self.extra_param: str = extra_param\n\ndef my_service_generator(**params):\n    params['extra_param'] = 'Hello World!'\n    return MyService(**params)\n\napp.add_scoped(MyService, my_service_generator)\n</code></pre> <p>Esto ofrece una mayor flexibilidad en la inyecci\u00f3n de dependencias, ya que el generador permite no solo personalizar la creaci\u00f3n de la dependencia, sino tambi\u00e9n realizar cualquier acci\u00f3n adicional seg\u00fan sea necesario.</p> <p>Es importante tener en cuenta que el generador ser\u00e1 invocado dependiendo del ciclo de vida de la dependencia (<code>Singleton</code>, <code>Scoped</code>, <code>Transient</code>):</p> <ul> <li>Singleton: El generador se invocar\u00e1 solo una vez durante todo el proyecto.</li> <li>Scoped: Se ejecutar\u00e1 una vez por cada solicitud.</li> <li>Transient: Ser\u00e1 invocado cada vez que se necesite inyectar la dependencia.</li> </ul>"},{"location":"es/dependency_injection/#sobreescribir-override","title":"Sobreescribir (override)","text":"<p>Determinar si el registro de la dependencia es una sobreescritura requiere un par\u00e1metro adicional, el cual sirve para reemplazar una dependencia ya registrada. Este par\u00e1metro debe ser pasado como un argumento por palabra clave, es decir, debe referenciarse expl\u00edcitamente usando el nombre del par\u00e1metro.</p> Python<pre><code>app.add_scoped(MyService, override=True)\napp.add_scoped(AMyService, MyService, override=True)\napp.add_scoped(AMyService, MyService, my_generator, override=True)\n</code></pre>"},{"location":"es/dependency_injection/#remover-dependencias","title":"Remover dependencias","text":"<p>Para remover una dependencia ya existente se puede usar el m\u00e9todo <code>remove_&lt;type&gt;</code>.</p> Python<pre><code>app.remove_singleton(MyServiceSingleton)\napp.remove_scoped(AMyServiceScoped)\napp.remove_transient(AMyServiceTransient)\n</code></pre>"},{"location":"es/dependency_injection/#inyeccion-de-las-dependencias","title":"Inyecci\u00f3n de las dependencias","text":"<p>Las dependencias pueden ser inyectadas en varios lugares, desde el controlador, los m\u00e9todos de validaci\u00f3n de los DTO y otras dependencias. Para que esto sea posible es muy importante haberlas almacenado previamente con alguno de los m\u00e9todos asociados a este <code>add_singleton</code>, <code>add_scoped</code> o <code>add_transient</code>.</p> <p>En el caso de los controladores se inyectar\u00e1n directamente en la acci\u00f3n.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok, NotFound\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/get/{id}')\n    async def get_by_id(self, id: int, service: AUserService) -&gt; UserResponseDto:\n        user = await service.get_by_id(id) #(1)\n        # Your code here\n</code></pre> <ol> <li> <p>Warning</p>    Servicio simulado para el ejemplo. </li> </ol> <p>En el caso de los validadores de los DTO se usan en cada uno de estos.</p> Python<pre><code>from typing import Any, Dict, List\n\nfrom cafeto.models import BaseModel, validate\nfrom cafeto.errors import FieldError, Error, ModelError\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str\n\n    @validate('username')\n    async def validate_username(value: str, data: Dict[str, Any], service: AUserService):\n        await service.some_required_validation() #(1)\n        # Your code here\n\n    @validate()\n    async def validate(value: str, data: Dict[str, Any], service: AUserService):\n        await service.some_required_validation() #(2)\n        # Your code here\n</code></pre> <ol> <li> <p>Warning</p>    Servicio simulado para el ejemplo. </li> <li> <p>Warning</p> <p>Servicio simulado para el ejemplo.</p> </li> </ol> <p>En el caso de las otras dependencias estas se inyectan desde el constructor de la clase.</p> Python<pre><code>from abc import ABC\nfrom typing import Optional\n\nfrom cafeto import App\n\nclass AUserService(ABC):\n    def __init__(self, some_service: ASomeService) -&gt; None:\n        ...\n\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        ...\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        ...\n\nclass UserService(AUserService):\n    def __init__(self, some_service: ASomeService) -&gt; None:\n        self.some_service = some_service\n\n    async def create_user(self, user: CreateUserRequestDto) -&gt; bool:\n        await self.some_service.do_something_user(user) #(1)\n        # Your code here.\n\n    async def get_by_id(self, id: int) -&gt; Optional[UserResponseDto]:\n        await self.some_service.do_something_id(id) #(2)\n        # Your code here.\n</code></pre> <ol> <li> <p>Warning</p>    Servicio simulado para el ejemplo. </li> <li> <p>Warning</p> <p>Servicio simulado para el ejemplo.</p> </li> </ol> <p>Es importante aclarar que, una vez se inicia con la primera dependencia, esta crear\u00e1 un sistema recursivo donde se analizar\u00e1 cada dependencia para poder inyectar de forma correcta cada una de ellas donde se necesite.</p>"},{"location":"es/dependency_injection/#informacion-importante","title":"Informaci\u00f3n importante","text":"<p>Las dependencias de tipo <code>Singleton</code>, al ser permanentes, se comparten entre los diferentes usuarios que ingresan al sistema en cada solicitud. Esto significa que la informaci\u00f3n almacenada en estas debe ser, preferiblemente, informaci\u00f3n que no est\u00e9 relacionada con la sesi\u00f3n del usuario y que sea inmutable.</p>"},{"location":"es/dependency_injection/#por-que-es-importante-esto","title":"\u00bfPor qu\u00e9 es importante esto?","text":"<ol> <li> <p>Si se almacena informaci\u00f3n relacionada con la sesi\u00f3n del usuario, esta podr\u00eda solaparse entre solicitudes diferentes, generando un agujero de seguridad que podr\u00eda permitir el acceso no autorizado a determinados servicios.</p> </li> <li> <p>Si la informaci\u00f3n es mutable (independientemente del tipo), podr\u00eda sobrescribirse de manera insegura entre solicitudes concurrentes. Esto es lo que se conoce como <code>Condiciones de carrera (Race Conditions)</code>. Aunque existe una forma de prevenirlo mediante el uso de bloqueos temporales del recurso, no se recomienda hacerlo para evitar generar cuellos de botella, ya que el bloqueo puede afectar el rendimiento general del sistema.</p> </li> </ol>"},{"location":"es/dependency_injection/#ejemplo","title":"Ejemplo","text":"Python<pre><code>import asyncio\nfrom typing import List\n\nclass MyServiceSingleton:\n    def __init__(self):\n        self.values: List[int] = []\n        self._lock = asyncio.Lock()\n\n    async def add_value(self, value: int) -&gt; None:\n        async with self._lock:  # Block the resource\n            self.values.append(value)\n\n    async def get_values(self) -&gt; List[int]:\n        async with self._lock: # Block the resource\n            return self.values\n</code></pre> <p>Como se muestra en el ejemplo, esto puede causar tiempos de espera no deseados. Por esta raz\u00f3n, se recomienda optar por una arquitectura sin bloqueos (<code>No Lock Contention</code>) para mejorar la eficiencia del sistema.</p>"},{"location":"es/dependency_injection/#conclusion","title":"Conclusi\u00f3n","text":"<p>Es crucial entender los tres tipos de inyecci\u00f3n de dependencias (<code>Singleton</code>, <code>Transient</code> y <code>Scoped</code>) y los dos m\u00e9todos para implementar la inyecci\u00f3n de dependencias, ya sea a trav\u00e9s de <code>interfaces</code> o <code>clases</code>. Esta comprensi\u00f3n te permitir\u00e1 dise\u00f1ar sistemas m\u00e1s flexibles, mantenibles y escalables, adapt\u00e1ndose a las necesidades espec\u00edficas de cada proyecto.</p>"},{"location":"es/events/","title":"Eventos","text":""},{"location":"es/events/#introduccion","title":"Introducci\u00f3n","text":"<p>Cafeto presenta tres tipos de eventos que se pueden usar para realizar acciones globales sobre las solicitudes. Estas acciones se aplicar\u00e1n a cada acci\u00f3n en toda la aplicaci\u00f3n y se ejecutar\u00e1n en el orden en que se agreguen.</p> <p>Los eventos son similares a los Middleware, pero son m\u00e1s sencillos de implementar y proporcionan acceso a una gran cantidad de informaci\u00f3n del sistema sobre la solicitud en curso.</p> <p>Los eventos disponibles en Cafeto son: <code>OnBeforeAction</code>, <code>OnExecuteAction</code> y <code>OnAfterAction</code>.</p>"},{"location":"es/events/#onbeforeaction","title":"OnBeforeAction","text":"<p>Se ejecuta antes de la ejecuci\u00f3n de la acci\u00f3n del controlador y recibe dos par\u00e1metros: <code>controller: BaseController</code> y <code>action: Action</code>.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.events import OnBeforeAction\nfrom cafeto.types import Action\n\napp: App = App()\n\ndef get_on_before_action(controller: BaseController, action: Action):\n    # Your Code\n\nOnBeforeAction.add(get_on_before_action)\n</code></pre>"},{"location":"es/events/#onexecuteaction","title":"OnExecuteAction","text":"<p>Se ejecuta junto con la ejecuci\u00f3n de la acci\u00f3n del controlador y recibe tres par\u00e1metros: <code>controller: BaseController</code>, <code>action: Action</code> y <code>request_model: BaseModel</code>.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.events import OnExecuteAction\nfrom cafeto.types import Action\n\napp: App = App()\n\ndef get_on_execute_action(controller: BaseController, action: Action, request_model: BaseRequest):\n    # Your Code\n\nOnExecuteAction.add(get_on_execute_action)\n</code></pre>"},{"location":"es/events/#onafteraction","title":"OnAfterAction","text":"<p>Se ejecuta despu\u00e9s de la ejecuci\u00f3n de la acci\u00f3n del controlador y recibe cuatro par\u00e1metros: <code>controller: BaseController</code>, <code>action: Action</code>, <code>request_model: BaseModel</code> y <code>response: Response</code>.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.events import OnAfterAction\nfrom cafeto.types import Action\nfrom cafeto.responses import Response\n\napp: App = App()\n\ndef get_on_after_action(controller: BaseController, action: Action, request_model: BaseRequest, response: Response):\n    # Your Code\n\nOnAfterAction.add(get_on_after_action)\n</code></pre> <p>Los eventos tambi\u00e9n pueden ser removidos.</p> Python<pre><code>OnAfterAction.remove(get_on_after_action)\n</code></pre> <p>Los eventos tambi\u00e9n pueden ser as\u00edncronos.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\nfrom cafeto.events import OnAfterAction\nfrom cafeto.types import Action\nfrom cafeto.responses import Response\n\napp: App = App()\n\nasync def get_on_after_action(controller: BaseController, action: Action, request_model: BaseRequest, response: Response):\n    # Your Code\n\nOnAfterAction.add(get_on_after_action)\n</code></pre>"},{"location":"es/params/","title":"Par\u00e1metros","text":""},{"location":"es/params/#introduccion","title":"Introducci\u00f3n","text":"<p>Los par\u00e1metros en una API son elementos clave que permiten personalizar las solicitudes y respuestas. Se dividen en tres tipos principales:</p> Path Parameters (Par\u00e1metros de ruta) <p>Definen partes variables de la URL.</p> <p>Importancia: Permiten acceder a recursos espec\u00edficos de manera directa y estructurada.</p> Query String Parameters (Par\u00e1metros de cadena de consulta) <p>Se a\u00f1aden a la URL despu\u00e9s del s\u00edmbolo <code>?</code> y est\u00e1n separados por <code>&amp;</code>.</p> <p>Importancia: Facilitan la filtraci\u00f3n, clasificaci\u00f3n y personalizaci\u00f3n de los resultados sin modificar la ruta.</p> Headers (Cabeceras) <p>Se env\u00edan como parte de la solicitud HTTP.</p> <p>Importancia: Proporcionan metadatos sobre la solicitud, como autenticaci\u00f3n, formato del contenido, entre otros.</p> <p>Estos par\u00e1metros son esenciales para la flexibilidad, seguridad y eficiencia de la comunicaci\u00f3n entre el cliente y el servidor en una API.</p>"},{"location":"es/params/#parametros-en-la-ruta-path","title":"Par\u00e1metros en la ruta (path)","text":"<p>Es posible obtener par\u00e1metros en la URL tal como se hace en Starlette, pero se obtendr\u00e1n como un par\u00e1metro en la acci\u00f3n.</p> Python<pre><code>from typing import Dict\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/get-params/{id}')\n    async def get_params(self, id: int) -&gt; Dict[str, int]:\n        return Ok({'id': id})\n</code></pre> <p>El API se podr\u00e1 consumir as\u00ed:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params/1 \\\n     -H \"Content-Type: application/json\"\n</code></pre> <p>Nota: A diferencia de Starlette, el tipo del par\u00e1metro no se define en la URL, sino en el par\u00e1metro de la acci\u00f3n:</p> <p>Danger</p> <p>Forma incorrecta</p> Python<pre><code>@app.get('/get-params/{id:int}')\nasync def get_params(self, id):\n    ...\n</code></pre> <p>Success</p> <p>Forma correcta</p> Python<pre><code>@app.get('/get-params/{id}')\nasync def get_params(self, id: int):\n    ...\n</code></pre> <p>Estos par\u00e1metros son obligatorios y se pueden definir cuantos sean necesarios.</p> Python<pre><code>from typing import Dict, Any\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/get-params/{id}/{group}')\n    async def get_params(self, id: int, group: str) -&gt; Dict[str, Any]:\n        return Ok({'id': id, 'group': group})\n</code></pre> <p>El API se podr\u00e1 consumir as\u00ed:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params/1/employee \\\n     -H \"Content-Type: application/json\"\n</code></pre>"},{"location":"es/params/#parametros-en-el-query-string","title":"Par\u00e1metros en el query string","text":"<p>Es posible obtener par\u00e1metros desde query string as\u00ed:</p> Python<pre><code>from typing import Dict\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/get-params', query=['group'])\n    async def get_params(self, group: str) -&gt; Dict[str, str]:\n        return Ok({'group': group})\n</code></pre> <p>El API se podr\u00e1 consumir as\u00ed:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params?group=employee \\\n     -H \"Content-Type: application/json\" \n</code></pre>"},{"location":"es/params/#parametros-en-las-cabeceras-headers","title":"Par\u00e1metros en las cabeceras (headers)","text":"<p>Es posible obtener par\u00e1metros desde las cabeceras as\u00ed:</p> Python<pre><code>from typing import Dict\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/get-params', headers=['token'])\n    async def get_params(self, token: str) -&gt; Dict[str, str]:\n        return Ok({'token': token})\n</code></pre> <p>El API se podr\u00e1 consumir as\u00ed:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params \\\n     -H \"Content-Type: application/json\" \\\n     -H \"token: token123\" \n</code></pre> <p>Es posible obtener varios datos de los par\u00e1metros de las tres diferentes fuentes as\u00ed:</p> Python<pre><code>from typing import Dict, Any\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get(\n        '/get-params/{id}/{group}',\n        query=['confirm'],\n        headers=['token', 'language'])\n    async def get_params(\n        self,\n        id: int,\n        token: str,\n        confirm: int,\n        group: str,\n        language: str) -&gt; Dict[str, Any]:\n        return Ok({\n            'id': id,\n            'token': token,\n            'confirm': confirm,\n            'group': group,\n            'language': language\n        })\n</code></pre> <p>El API se podr\u00e1 consumir as\u00ed:</p> Bash<pre><code>curl -X GET http://127.0.0.1:8000/params/get-params/1/employee?confirm=1 \\\n     -H \"Content-Type: application/json\" \\\n     -H \"token: token123\" \\\n     -H \"language: esCO\" \n</code></pre> <p>Como se puede ver en el ejemplo anterior, el orden de los par\u00e1metros no importa realmente.</p> <p>Los par\u00e1metros de las <code>cabeceras (headers)</code> y del <code>query string</code> pueden tener valores por defecto. Esto significa que si el par\u00e1metro no se encuentra, se usar\u00e1 el valor asignado por defecto en la definici\u00f3n de la acci\u00f3n.</p> Python<pre><code>from typing import Dict\n\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass ParamsController(BaseController):\n    @app.get('/create', query=['group'])\n    async def create(self, group: str='employee') -&gt; Dict[str, str]:\n        return Ok({'group': group})\n</code></pre> <p>Para este \u00faltimo ejemplo, <code>group</code> al tener un valor por defecto, debe estar al final de los par\u00e1metros y se usar\u00e1 este valor si el par\u00e1metro no se encuentra en el <code>query string</code>.</p>"},{"location":"es/request/#introduccion","title":"Introducci\u00f3n","text":"<p>Un <code>request</code> en un servicio es una petici\u00f3n que un cliente env\u00eda a un servidor para que realice una operaci\u00f3n espec\u00edfica. Esta petici\u00f3n incluye informaci\u00f3n clave, como el m\u00e9todo HTTP (GET, POST, PUT, DELETE, etc.), la URL que identifica el recurso solicitado, los encabezados (headers) con datos contextuales (como autenticaci\u00f3n o tipo de contenido) y, opcionalmente, un cuerpo (body) que contiene datos adicionales necesarios para procesar la solicitud, como formularios o JSON. El servidor procesa el request y devuelve una respuesta que indica el resultado de la operaci\u00f3n.</p> <p>Los <code>request</code> llegan a trav\u00e9s de un DTO (Data Transfer Object). Es una manera de encapsular datos en un formato estructurado y tipado para garantizar que la informaci\u00f3n se transmita de manera consistente y segura.</p>"},{"location":"es/request/#uso","title":"Uso","text":"Python<pre><code>from datetime import date\nfrom typing import Optional\n\nfrom cafeto import App\nfrom cafeto.models import BaseModel\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\nclass ExtraDataRequestDto(BaseModel):\n    nickname: str\n\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str\n    confirm_password: str\n    name: Optional[str]\n    birth_date: date\n    extra_data: ExtraDataRequestDto\n\napp: App = App()\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, user: CreateUserRequestDto) -&gt; Dict[str, Any]: #(1)\n        return Ok({\n            'username': user.username,\n            'password': user.password,\n            'name': user.name,\n            'birth_date': user.birth_date,\n            'extra_data': {\n                'nickname': user.extra_data.nickname\n            }\n        })\n\napp.map_controllers()\n</code></pre> <ol> <li>Aqu\u00ed se recibe el objeto <code>CreateUserRequestDto</code>. Python<pre><code>    async def create(self, user: CreateUserRequestDto)\n</code></pre></li> </ol> <p>Para este ejemplo, solo se deben mapear los campos de la clase <code>CreateUserRequestDto</code>, incluyendo la clase <code>ExtraDataRequestDto</code> en un JSON as\u00ed:</p> Bash<pre><code>curl -X POST http://127.0.0.1:8000/user/create \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n           \"username\": \"jon-d\",\n           \"password\": \"my-password-123\",\n           \"confirm_password\": \"my-password-123\",\n           \"name\": \"Jon Doe\",\n           \"birth_date\": \"1984-01-01\",\n           \"extra_data\": {\n            \"nickname\": \"Jon\"\n           }\n         }'\n</code></pre>"},{"location":"es/request/#cargar-archivos","title":"Cargar archivos","text":"<p>Es posible crear una acci\u00f3n para cargar archivos. Para esto, se requiere que el request sea del tipo <code>UploadFile</code>.</p> Python<pre><code>from cafeto import App\nfrom cafeto.datastructures import UploadFile\nfrom cafeto.models import BaseModel\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\n@app.controller()\nclass StorageController(BaseController):\n    @app.post('/upload')\n    async def upload(self, file: UploadFile) -&gt; Ok:\n        return Ok({'file': file.filename})\n</code></pre> <p>El API se podr\u00e1 consumir as\u00ed:</p> Bash<pre><code>curl -X POST http://127.0.0.1:8000/upload \\\n     -F \"file=@path/to/your/file\"\n</code></pre>"},{"location":"es/response/","title":"Respuestas","text":""},{"location":"es/response/#introduccion","title":"Introducci\u00f3n","text":"<p>La respuesta de un servicio es el resultado que se env\u00eda al cliente tras procesar una solicitud. Puede tener diferentes formatos dependiendo de la necesidad, como JSON para datos estructurados, texto plano para mensajes simples, HTML para contenido web, archivos binarios para descargas o incluso respuestas en streaming para datos enviados progresivamente. Su contenido y c\u00f3digo de estado (como 200 para \u00e9xito o 400 para errores) indican el resultado de la operaci\u00f3n realizada.</p> <p>En sus acciones, Cafeto utiliza las respuestas est\u00e1ndar de <code>Starlette</code>, que incluyen: <code>JSON</code>, <code>HTML</code>, <code>Texto Plano</code>, <code>Archivos Binarios</code>, <code>Streaming</code> o <code>None</code> (sin contenido). Adem\u00e1s, Cafeto ofrece dos respuestas adicionales para manejar DTOs: <code>ModelResponse</code> y <code>ModelWSResponse</code> (espec\u00edfica para websockets). Este enfoque lo llamamos el <code>M\u00e9todo Cl\u00e1sico</code>.</p> <p>Complementando las respuestas del <code>M\u00e9todo Cl\u00e1sico</code>, Cafeto introduce un sistema adicional denominado <code>M\u00e9todo Unificado</code>. </p> <p>La principal diferencia es que en el <code>M\u00e9todo Cl\u00e1sico</code> el desarrollador debe elegir manualmente el tipo de respuesta seg\u00fan el dato a retornar. En contraste, el <code>M\u00e9todo Unificado</code> siempre utiliza una \u00fanica respuesta que puede detectar autom\u00e1ticamente el tipo de dato a retornar, simplificando el proceso.</p> <p>En el <code>M\u00e9todo Cl\u00e1sico</code>, el c\u00f3digo de estado por defecto (<code>statusCode</code>) es siempre <code>200</code>, y debe ajustarse manualmente seg\u00fan las necesidades. Por otro lado, en el <code>M\u00e9todo Unificado</code>, cada tipo de respuesta est\u00e1 asociado autom\u00e1ticamente a un c\u00f3digo de estado espec\u00edfico.</p> Estilo UnificadoEstilo Cl\u00e1sico <ul> <li>Ok (Respuesta con c\u00f3digo 200)</li> <li>BadRequest (Respuesta con c\u00f3digo 400)</li> <li>NoContent (Respuesta con c\u00f3digo 204)</li> <li>ETC...</li> </ul> <ul> <li>Response (Respuesta sin contenido)</li> <li>JSONResponse (Respuesta de un JSON)</li> <li>PlainTextResponse (Respuesta de texto plano)</li> <li>HTMLResponse (Respuesta de texto con formato HTML)</li> <li>FileResponse (Respuesta de un archivo binario)</li> <li>StreamingResponse (Respuesta en forma de streaming)</li> <li>ModelResponse (Respuesta de un modelo)</li> <li>ModelWSResponse (Respuesta de un modelo, pero desde un websocket)</li> </ul>"},{"location":"es/response/#respuesta-json","title":"Respuesta JSON","text":"Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; Dict[str, str]:\n        return Ok({'Hello': 'Hola'})\n</code></pre> Python<pre><code>from cafeto.responses import JSONResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; JSONResponse:\n        return JSONResponse({'Hello': 'Hola'})\n</code></pre> <p>Es importante recordar que el tipo de respuesta de las acciones no es estrictamente obligatorio y solo se usa para la documentaci\u00f3n con OpenApi, pero se sugiere usarla para tener un proyecto m\u00e1s claro y f\u00e1cil de mantener.</p> Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self):  # No response\n        return Ok({'Hello': 'Hola'})\n</code></pre> Python<pre><code>from cafeto.responses import JSONResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self):  # No response\n        return JSONResponse({'Hello': 'Hola'})\n</code></pre>"},{"location":"es/response/#respuesta-dto","title":"Respuesta DTO","text":"Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.get() #(1)\n        return Ok(CreateUserResponseDto(**user)) #(2)\n</code></pre> <ol> <li> <p>Warning</p> <p>Servicio simulado para el ejemplo.</p> </li> <li> <p>Aqu\u00ed se env\u00eda el objeto <code>CreateUserResponseDto</code></p> </li> </ol> Python<pre><code>from cafeto.responses import ModelResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; CreateUserResponseDto:\n        user = &lt;some_user_service&gt;.get() #(1)\n        return ModelResponse(CreateUserResponseDto(**user)) #(2)\n</code></pre> <ol> <li> <p>Warning</p> <p>Servicio simulado para el ejemplo.</p> </li> <li> <p>Aqu\u00ed se env\u00eda el objeto <code>CreateUserResponseDto</code></p> </li> </ol>"},{"location":"es/response/#respuesta-lista-de-dtos","title":"Respuesta Lista de DTOs","text":"Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; List[CreateUserResponseDto]:\n        users = &lt;some_user_service&gt;.get_all()\n        return Ok(\n            [CreateUserResponseDto(**user) for user in users]\n        )\n</code></pre> Python<pre><code>from cafeto.responses import ModelResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/view')\n    async def view(self) -&gt; List[CreateUserResponseDto]:\n        users = &lt;some_user_service&gt;.get_all()\n        return ModelResponse(\n            [CreateUserResponseDto(**user) for user in users]\n        )\n</code></pre>"},{"location":"es/response/#respuesta-sin-contenido","title":"Respuesta sin contenido","text":"Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.responses import NoContent\n\n@app.controller()\nclass UserController:\n    @app.post('/check')\n    async def check(self) -&gt; None:\n        return NoContent()\n</code></pre> Python<pre><code>from cafeto.responses import Response\n\n@app.controller()\nclass UserController:\n    @app.post('/check')\n    async def check(self) -&gt; Response:\n        return Response()\n</code></pre>"},{"location":"es/response/#respuesta-archivo-o-binario","title":"Respuesta archivo o binario","text":"Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.responses import Ok, FileResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; FileResponse:\n        return Ok(FileResponse('/path/to/file'))\n</code></pre> Python<pre><code>from cafeto.responses import FileResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; FileResponse:\n        return FileResponse('/path/to/file')\n</code></pre>"},{"location":"es/response/#respuesta-texto-plano","title":"Respuesta texto plano","text":"Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; str:\n        return Ok('Hello World!')\n</code></pre> Python<pre><code>from cafeto.responses import PlainTextResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; PlainTextResponse:\n        return PlainTextResponse('Hello World!')\n</code></pre>"},{"location":"es/response/#respuesta-html","title":"Respuesta HTML","text":"Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.responses import Ok, Format\nfrom cafeto.responses.types import TEXT_HTML\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; Format[str, TEXT_HTML]:\n        return Ok('&lt;div&gt;Hello World!&lt;/div&gt;', format=TEXT_HTML)\n</code></pre> Python<pre><code>from cafeto.responses import HTMLResponse\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; HTMLResponse:\n        return HTMLResponse('&lt;div&gt;Hello World!&lt;/div&gt;')\n</code></pre>"},{"location":"es/response/#respuesta-streaming","title":"Respuesta Streaming","text":"Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.responses import Ok, Format\nfrom cafeto.responses.types import TEXT_HTML\n\nasync def slow_numbers(minimum, maximum):\n    yield '&lt;ul&gt;'\n    for number in range(minimum, maximum + 1):\n        yield f'&lt;li&gt;{number}&lt;/li&gt;'\n        await asyncio.sleep(0.5)\n    yield '&lt;/ul&gt;'\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; Format[str, TEXT_HTML]:\n        generator = slow_numbers(1, 10)\n        return Ok(generator, format=TEXT_HTML)\n</code></pre> Python<pre><code>from cafeto.responses import StreamingResponse\n\nasync def slow_numbers(minimum, maximum):\n    yield '&lt;ul&gt;'\n    for number in range(minimum, maximum + 1):\n        yield f'&lt;li&gt;{number}&lt;/li&gt;'\n        await asyncio.sleep(0.5)\n    yield '&lt;/ul&gt;'\n\n@app.controller()\nclass UserController:\n    @app.get('/check')\n    async def check(self) -&gt; HTMLResponse:\n        generator = slow_numbers(1, 10)\n        return StreamingResponse(generator)\n</code></pre>"},{"location":"es/response/#conclusion","title":"Conclusi\u00f3n","text":"<p>Ambos sistemas son bastante buenos, cada uno tiene sus pros y sus contras. Queda a discreci\u00f3n de cada desarrollador usar uno u otro. Se recomienda elegir uno desde el comienzo para evitar la confusi\u00f3n y no combinar los dos sistemas, as\u00ed se tendr\u00e1 mayor orden y control sobre el sistema.</p>"},{"location":"es/schema/","title":"Esquema","text":""},{"location":"es/schema/#introduccion","title":"Introducci\u00f3n","text":"<p>Usar un esquema como OpenAPI para mostrar las entradas y salidas de una API ofrece varias ventajas significativas:</p> <ul> <li> <p>Documentaci\u00f3n clara y detallada: OpenAPI permite crear una documentaci\u00f3n exhaustiva que describe los endpoints, m\u00e9todos HTTP, par\u00e1metros, respuestas y otros elementos de la API. Esto facilita la comprensi\u00f3n y el uso de la API por parte de otros desarrolladores.</p> </li> <li> <p>Facilita la colaboraci\u00f3n: Con una documentaci\u00f3n bien definida, los equipos de desarrollo pueden colaborar de manera m\u00e1s efectiva. Los desarrolladores pueden entender r\u00e1pidamente c\u00f3mo interactuar con la API, lo que reduce la necesidad de comunicaci\u00f3n adicional.</p> </li> <li> <p>Pruebas y depuraci\u00f3n m\u00e1s sencillas: Herramientas como Swagger UI proporcionan una interfaz gr\u00e1fica interactiva para probar y explorar las APIs. Esto permite a los desarrolladores y testers verificar r\u00e1pidamente el funcionamiento de los endpoints y detectar posibles errores.</p> </li> <li> <p>Estandarizaci\u00f3n: OpenAPI sigue un est\u00e1ndar reconocido para definir y describir APIs. Esto asegura que la documentaci\u00f3n sea consistente y comprensible, independientemente de qui\u00e9n la haya creado.</p> </li> <li> <p>Generaci\u00f3n autom\u00e1tica de c\u00f3digo: Muchas herramientas pueden generar autom\u00e1ticamente c\u00f3digo cliente y servidor a partir de una especificaci\u00f3n OpenAPI. Esto acelera el desarrollo y asegura que el c\u00f3digo generado est\u00e9 alineado con la documentaci\u00f3n.</p> </li> <li> <p>Mejora la mantenibilidad: Tener una documentaci\u00f3n actualizada y precisa facilita el mantenimiento de la API. Los cambios en los endpoints, par\u00e1metros o respuestas se pueden reflejar r\u00e1pidamente en la documentaci\u00f3n, asegurando que todos los usuarios de la API est\u00e9n al tanto de las modificaciones.</p> </li> <li> <p>Validaci\u00f3n de datos: OpenAPI permite definir esquemas de validaci\u00f3n para las entradas y salidas de la API. Esto asegura que los datos enviados y recibidos cumplan con los formatos esperados, reduciendo errores y mejorando la robustez de la API.</p> </li> <li> <p>Seguridad: La especificaci\u00f3n OpenAPI permite definir esquemas de seguridad, como autenticaci\u00f3n y autorizaci\u00f3n, lo que ayuda a asegurar que la API est\u00e9 protegida contra accesos no autorizados.</p> </li> </ul> <p>En resumen, usar un esquema como OpenAPI para documentar las entradas y salidas de una API proporciona claridad, facilita la colaboraci\u00f3n, mejora la mantenibilidad y seguridad, y permite aprovechar herramientas avanzadas para pruebas y generaci\u00f3n de c\u00f3digo.</p>"},{"location":"es/schema/#openapi","title":"OpenAPI","text":"<p>OpenAPI especifica un est\u00e1ndar para definir y describir APIs. Con OpenAPI, puedes crear una documentaci\u00f3n clara y detallada que describe los endpoints, m\u00e9todos HTTP, par\u00e1metros, respuestas y otros elementos de tu API. Esto facilita la comprensi\u00f3n y el uso de la API por parte de otros desarrolladores.</p>"},{"location":"es/schema/#swagger","title":"Swagger","text":"<p>Swagger es un conjunto de herramientas creadas en torno a la especificaci\u00f3n OpenAPI. Incluye Swagger UI, que proporciona una interfaz gr\u00e1fica interactiva para probar y explorar las APIs.</p>"},{"location":"es/schema/#integracion","title":"Integraci\u00f3n","text":"<p>Para activar la integraci\u00f3n con OpenApi y Swagger, solo necesitas activarlos.</p> Python<pre><code>from cafeto import App\nfrom cafeto.mvc import BaseController\n\n\napp: App = App(debug=True)\n\n@app.controller()\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, data: CreateUserRequestDto) -&gt; CreateUserResponseDto:\n        # My code here\n\napp.map_controllers()\napp.use_schema()\nif app.debug:\n    app.use_swagger()\n</code></pre> <p>Existen dos puntos de entrada para ver la documentaci\u00f3n en OpenApi en formato <code>json</code> y <code>yaml</code>:</p> <ul> <li>http://127.0.0.1:8000/schema/openapi.json</li> <li>http://127.0.0.1:8000/schema/openapi.yaml</li> </ul> <p>Y para ver la interfaz de Swagger UI, accede a:</p> <ul> <li>http://127.0.0.1:8000/schema/swagger-ui.html</li> </ul>"},{"location":"es/schema/#documentacion","title":"Documentaci\u00f3n","text":"<p>La documentaci\u00f3n OpenApi se crear\u00e1 de forma autom\u00e1tica tomando como fuente de datos las acciones de los controladores. Entre la informaci\u00f3n relevante se incluyen los datos de salida (la respuesta de las acciones) y los datos de entrada, tanto de los request como los par\u00e1metros <code>path</code>, <code>querystring</code>, <code>headers</code> y los datos que retornan. Tambi\u00e9n se tomar\u00e1 en cuenta si las acciones tienen control de acceso con el decorador <code>@app.requires</code>.</p> <p>Tambi\u00e9n es una buena idea proporcionar documentaci\u00f3n general sobre la API.</p> Python<pre><code>from cafeto import SecurityScheme, Info, Contact, License, ExternalDocs\n\n\nsecurity_scheme: SecurityScheme = SecurityScheme(\n    name='auth',\n    bearer_format='JWT',\n    type='http',\n    scheme='bearer'\n)\n\ninfo: Info = Info(\n    title='My API',\n    description='Lorem ipsum dolor sit amet, consectetuer adipiscing elit.',\n    version='1.0.0',\n    terms_of_service='http://my_api_terms_of_service.html',\n    contact=Contact(\n        name='Cafeto',\n        url='http://my_api_contact.html',\n        email='my_api@email.com'\n    ),\n    license=License(\n        name='My License',\n        url='http://my_license.html'\n    )\n)\n\nexternal_docs: ExternalDocs = ExternalDocs(\n    description='Find more info here',\n    url='http://my_docs.html'\n)\n\napp.use_schema(\n    openapi_version='3.0.1', # Por defecto\n    info=info,\n    security_scheme=security_scheme,\n    external_docs=external_docs\n)\n</code></pre> <p>Es posible agregar documentaci\u00f3n adicional a los controladores y acciones usando docstrings de Python.</p> Python<pre><code>@app.controller()\nclass HomeController(BaseController):\n    '''\n    description: Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n    '''\n    @app.get('/hello')\n    async def hello(self) -&gt; UserResponseDto:\n        '''\n        summary: Lorem ipsum.\n        description: Lorem ipsum dolor sit amet, consectetuer adipiscing elit.\n        responses:\n            200:\n                default: true\n                description: Lorem ipsum\n            400:\n                description: Lorem ipsum\n        '''\n</code></pre> <p>El formato utilizado para esta documentaci\u00f3n es <code>yml</code>. En la documentaci\u00f3n de la acci\u00f3n, en la secci\u00f3n <code>responses</code>, existe la opci\u00f3n <code>default</code>. Si esta est\u00e1 en <code>true</code>, quiere decir que esta respuesta es la que corresponde al dato que retornar\u00e1 la acci\u00f3n.</p>"},{"location":"es/sponsor/","title":"Patrocinador","text":""},{"location":"es/sponsor/#introduction","title":"Introduction","text":"<p>Los proyectos de c\u00f3digo abierto dependen en gran medida del apoyo y las contribuciones de la comunidad. Las donaciones juegan un papel crucial en el sostenimiento del desarrollo, mantenimiento y crecimiento de estos proyectos. Al donar, ayudas a garantizar que el proyecto pueda seguir mejorando, a\u00f1adiendo nuevas caracter\u00edsticas y proporcionando actualizaciones oportunas. Tu apoyo es invaluable para mantener el proyecto vivo y pr\u00f3spero.</p>"},{"location":"es/starlette_request_object/","title":"Objeto Request (Starlette)","text":""},{"location":"es/starlette_request_object/#introduccion","title":"Introducci\u00f3n","text":"<p>En Starlette, el objeto <code>request</code> representa la solicitud HTTP que llega a un endpoint. Contiene informaci\u00f3n como los m\u00e9todos de la solicitud (GET, POST, etc.), encabezados, par\u00e1metros de ruta, cadena de consulta, cuerpo de la solicitud y m\u00e1s. Es esencial para acceder y manipular los datos de la solicitud entrante en tu aplicaci\u00f3n.</p> <p>El objeto <code>Request</code> de Starlette no se pierde y a\u00fan puede ser accedido desde el controlador.</p>"},{"location":"es/starlette_request_object/#uso","title":"Uso","text":"Python<pre><code>from cafeto import Response\nfrom cafeto.mvc import BaseController\n\n\n@app.controller()\nclass HomeController(BaseController):\n    @app.get('/hello')\n    async def hello(self) -&gt; Response:\n        print(self.request)  # Request object\n        return Response()\n</code></pre> <p>En caso de que la acci\u00f3n sea un websocket se debe usar:</p> Python<pre><code>from cafeto import Response\nfrom cafeto.mvc import BaseController\n\n\n@app.controller()\nclass HomeController(BaseController):\n    @app.websocket('/ws')\n    async def hello(self) -&gt; Response:\n        print(self.websocket)  # Request object\n        return Response()\n</code></pre>"},{"location":"es/validations/","title":"Validaciones","text":""},{"location":"es/validations/#introduccion","title":"Introducci\u00f3n","text":"<p>Las validaciones en una API son procesos que verifican que los datos enviados al servidor cumplen con ciertas reglas o criterios antes de ser procesados. Esto asegura que la informaci\u00f3n sea correcta, completa y segura.</p>"},{"location":"es/validations/#importancia","title":"Importancia","text":"<ul> <li>Prevenci\u00f3n de errores: Evita que datos incorrectos causen fallos en el sistema.</li> <li>Seguridad: Protege contra inyecciones de c\u00f3digo y otros ataques.</li> <li>Integridad de datos: Garantiza que los datos almacenados y procesados sean consistentes y confiables.</li> <li>Experiencia del usuario: Proporciona retroalimentaci\u00f3n inmediata sobre errores en los datos enviados.</li> </ul> <p>\u00a1Esencial para un funcionamiento robusto y seguro de la API!</p>"},{"location":"es/validations/#uso","title":"Uso","text":"<p>En Cafeto, los DTO ejecutar\u00e1n las validaciones que Pydantic tiene disponibles por defecto.</p> Python<pre><code>from typing import Optional\nfrom pydantic import Field\nfrom cafeto import BaseModel\n\n\nclass CreateUserRequestDto(BaseModel):\n    username: str = Field(min_length=3)\n    password: str\n    confirm_password: str\n    name: Optional[str]\n    birth_date: date\n</code></pre> <p>En el ejemplo anterior, los campos <code>username</code>, <code>password</code>, <code>confirm_password</code> y <code>birth_date</code> son obligatorios, mientras que el campo <code>name</code> es opcional, y el campo <code>username</code> tiene un l\u00edmite m\u00ednimo de 3 caracteres. Estas validaciones se ejecutar\u00e1n autom\u00e1ticamente cuando se consuma la acci\u00f3n y los errores se retornar\u00e1n con un <code>statusCode</code> <code>400</code>.</p> <p>Para las validaciones personalizadas, existe el decorador <code>@validate</code>. Este decorador recibe como par\u00e1metro el nombre del campo a validar; si no se provee este campo, se validar\u00e1 todo el modelo.</p> Python<pre><code>from datetime import date\nfrom typing import Any, Optional, Dict, List\n\nfrom pydantic import Field\nfrom cafeto import App\nfrom cafeto.models import BaseModel, validate\nfrom cafeto.errors import FieldError, ModelError, Error\nfrom cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n\nclass ExtraDataRequestDto(BaseModel):\n    nickname: str\n\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str = Field(min_length=3)\n    confirm_password: str\n    name: Optional[str]\n    birth_date: date\n    extra_data: ExtraDataRequestDto\n\n    @validate('password') #(1)\n    def validate_password(value: str, data: Dict[str, Any]) -&gt; str:\n        if value != data.get('confirm_password', None):\n            raise FieldError(Error('same-password', 'Password and confirm password must be the same'))\n        return value\n\n    @validate('birth_date') #(2)\n    def validate_birth_date(value: date, data: Dict[str, Any]) -&gt; date:\n        if value.year &lt;= 2000:\n            raise FieldError(Error('year-error', 'The year must be greater than 2000'))\n        return value\n\n    @validate() #(3)\n    async def validate(data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        errors: List[Error] = []\n        errors.append(Error('user-custom', 'Custom error'))\n        if len(errors) &gt; 0:\n            raise ModelError(errors)\n\n        return data\n\napp: App = App()\n\n@app.controller('/user')\nclass UserController(BaseController):\n    @app.post('/create')\n    async def create(self, user: CreateUserRequestDto) -&gt; Dict[str, str]:\n        return Ok({'hello': 'HomepageController'})\n\napp.map_controllers()\n</code></pre> <ol> <li> <p>Valida el campo <code>password</code>.</p> </li> <li> <p>Valida el campo <code>birth_date</code>.</p> </li> <li> <p>Valida todo el modelo.</p> </li> </ol> <p>El decorador <code>@validate</code> es similar a <code>@field_validator</code> de Pydantic y se desarroll\u00f3 con el fin de poder crear validaciones personalizadas y as\u00edncronas. Tambi\u00e9n soporta inyecci\u00f3n de dependencias en el m\u00e9todo sobre el cual se aplica.</p> Bash<pre><code>curl -X PUT http://127.0.0.1/user/create \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n           \"password\": \"pa\",\n           \"confirm_password\": \"other-password-123\",\n           \"birth_date\": \"1998-06-18\",\n           \"extra_data\": {}\n         }'\n</code></pre> <p>Si enviamos la solicitud anterior, obtendremos el siguiente resultado:</p> JSON<pre><code>{\n    \"errorList\": [\n        {\n            \"loc\": [\n                \"__model__\"\n            ],\n            \"type\": \"user-custom\",\n            \"msg\": \"Custom error\"\n        },\n        {\n            \"loc\": [\n                \"password\"\n            ],\n            \"type\": \"same-password\",\n            \"msg\": \"Password and confirm password must be the same\"\n        },\n        {\n            \"loc\": [\n                \"birth_date\"\n            ],\n            \"type\": \"year-error\",\n            \"msg\": \"The year must be greater than 2000\"\n        },\n        {\n            \"loc\": [\n                \"username\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        },\n        {\n            \"loc\": [\n                \"password\"\n            ],\n            \"type\": \"string_too_short\",\n            \"msg\": \"String should have at least 3 characters\"\n        },\n        {\n            \"loc\": [\n                \"name\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        },\n        {\n            \"loc\": [\n                \"extra_data\",\n                \"nickname\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        }\n    ]\n}\n</code></pre> <p>Este es m\u00e1s o menos el mismo formato en que Pydantic retorna la validaci\u00f3n de los datos.</p> <p><code>FieldError</code> se usa para lanzar una excepci\u00f3n cuando falla un campo del DTO y recibe como par\u00e1metro un objeto <code>Error</code>, que a su vez recibe los par\u00e1metros <code>type: str</code> y <code>msg: str</code>. Existe un tercer par\u00e1metro llamado <code>loc: List[str | int] | str | int</code>; si este no se usa, Pydantic lo har\u00e1 autom\u00e1ticamente.</p> <p>En el arreglo <code>loc</code>, la palabra <code>__model__</code> hace referencia a errores globales, es decir, que no est\u00e1n necesariamente asociados a ning\u00fan campo del DTO.</p>"},{"location":"es/validations/#informacion-importante","title":"Informaci\u00f3n importante","text":"<p>Es importante notar que estos m\u00e9todos son est\u00e1ticos, por lo que no reciben el par\u00e1metro <code>self</code>.</p> <p>Los par\u00e1metros del m\u00e9todo donde se aplica el decorador <code>@validate</code> son: <code>value</code> y <code>data</code>.</p> <ol> <li> <p>value: Es el valor actual del campo que se est\u00e1 validando y el tipo de dato ser\u00e1 el que se configur\u00f3 desde el modelo.</p> <p>Nota: Si el validador aplica para todo el modelo, el primer par\u00e1metro ser\u00e1 un diccionario con los datos de todo el modelo.</p> </li> <li> <p>data: Es un diccionario con los dem\u00e1s campos del modelo.</p> <p>Nota: Si el validador aplica para todo el modelo, el segundo par\u00e1metro no existe.</p> </li> </ol> <p>Como regla general, si no se necesita hacer uso del segundo par\u00e1metro, se suele llamar \"_\" (guion bajo).</p> Python<pre><code>@validate('birth_date') #(2)\ndef validate_birth_date(value: date, _: Dict[str, Any]) -&gt; date:\n</code></pre>"},{"location":"es/validations/#formato-de-los-errores","title":"Formato de los errores","text":"<p>Existe una forma adicional de retornar errores; para ello, se debe configurar la aplicaci\u00f3n para que los retorne con este formato.</p> Python<pre><code>from cafeto import CafetoConfig\n\nconfig: CafetoConfig = CafetoConfig(error_object=True)\napp: App = App(config=config)\n</code></pre> <p>En ese caso, los errores se lanzar\u00e1n con los dos formatos, el anteriormente visto y el nuevo.</p> JSON<pre><code>{\n    \"errorList\": [\n        {\n            \"loc\": [\n                \"__model__\"\n            ],\n            \"type\": \"user-custom\",\n            \"msg\": \"Custom error\"\n        },\n        {\n            \"loc\": [\n                \"password\"\n            ],\n            \"type\": \"same-password\",\n            \"msg\": \"Password and confirm password must be the same\"\n        },\n        {\n            \"loc\": [\n                \"birth_date\"\n            ],\n            \"type\": \"year-error\",\n            \"msg\": \"The year must be greater than 2000\"\n        },\n        {\n            \"loc\": [\n                \"username\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        },\n        {\n            \"loc\": [\n                \"password\"\n            ],\n            \"type\": \"string_too_short\",\n            \"msg\": \"String should have at least 3 characters\"\n        },\n        {\n            \"loc\": [\n                \"name\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        },\n        {\n            \"loc\": [\n                \"extra_data\",\n                \"nickname\"\n            ],\n            \"type\": \"missing\",\n            \"msg\": \"Field required\"\n        }\n    ],\n    \"errorObject\": {\n        \"__model__\": [\n            {\n                \"type\": \"user-custom\",\n                \"msg\": \"Custom error\"\n            }\n        ],\n        \"password\": [\n            {\n                \"type\": \"same-password\",\n                \"msg\": \"Password and confirm password must be the same\"\n            },\n            {\n                \"type\": \"string_too_short\",\n                \"msg\": \"String should have at least 3 characters\"\n            }\n        ],\n        \"birth_date\": [\n            {\n                \"type\": \"year-error\",\n                \"msg\": \"The year must be greater than 2000\"\n            }\n        ],\n        \"username\": [\n            {\n                \"type\": \"missing\",\n                \"msg\": \"Field required\"\n            }\n        ],\n        \"name\": [\n            {\n                \"type\": \"missing\",\n                \"msg\": \"Field required\"\n            }\n        ],\n        \"extra_data\": {\n            \"nickname\": [\n                {\n                    \"type\": \"missing\",\n                    \"msg\": \"Field required\"\n                }\n            ]\n        }\n    }\n}\n</code></pre> <p>En este caso, se lanzan dos tipos de errores: <code>errorList</code> y <code>errorObject</code>. En este \u00faltimo, el campo <code>loc</code> deja de existir y se convierte en las llaves anidadas del objeto con los errores.</p>"},{"location":"es/validations/#modificar-valores","title":"Modificar valores","text":"<p>El decorador <code>@validate</code> tambi\u00e9n sirve para modificar los valores del DTO al ser devueltos, es decir, no solo se pueden usar para validar datos sino para alterar los valores de estos.</p> <p>Nota: Es importante anotar que los validadores siempre deben devolver un valor, este valor ser\u00e1 el que finalmente se usar\u00e1 en el modelo.</p> Python<pre><code>class MyModelDto(BaseModel):\n    name: str\n\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        return value + ' - Hello'\n</code></pre> <p>El valor del campo <code>name</code> ser\u00e1 el valor asignado + \" - Hello\".</p>"},{"location":"es/validations/#modelos-anidados","title":"Modelos anidados","text":"<p>Si se requiere validar un modelo, donde uno de sus campos es otro modelo, debe poner atenci\u00f3n en la forma como estos se validan. Si usamos el decorador <code>@validate</code> sobre el campo que contiene el modelo anidado, no se realizar\u00e1n las validaciones personalizadas de este. Esto se debe a que el sistema debe determinar cu\u00e1l validaci\u00f3n se debe ejecutar y se dar\u00e1 prioridad a aquella que esta menos inmersa en el modelo.</p> Python<pre><code>class MyModelA(BaseModel):\n    name_a: str\n\n    @validate('name_a')\n    def validate_name_a(value: str, _: Dict[str, Any]) -&gt; str:\n        return value + ' - Hello A from MyModelA'\n\n\nclass MyModelB(BaseModel):\n    name_b: str\n    model_a: MyModelA\n\n    @validate('name_b')\n    def validate_name_b(value: str, _: Dict[str, Any]) -&gt; str:\n        return value + ' - Hello B'\n\n    @validate('model_a')\n    def validate_model_a_from_b(value: MyModelA, _: Dict[str, Any]) -&gt; MyModelA:\n        value.name_a += ' - Hello A from MyModelB'\n        return value\n</code></pre> <p>En este \u00faltimo ejemplo, la validaci\u00f3n <code>validate_name_a</code> y ninguna otra que se encuentre en el modelo <code>MyModelA</code> se ejecutar\u00e1, debido a que la validaci\u00f3n <code>validate_model_a_from_b</code> del modelo <code>MyModelB</code> la est\u00e1 sobrescribiendo.</p>"},{"location":"es/validations/#validadores","title":"Validadores","text":"<p>Como se puede observar en los ejemplos anteriores, las validaciones est\u00e1n asociadas a los DTO. Sin embargo, es posible que no siempre se desee este comportamiento. Para estos casos, existen los validadores. Estos son clases a los que tambi\u00e9n se les aplica el decorador <code>@validate</code>, ya sea para validar un campo o todo el modelo, al igual que los DTO. Para utilizar estos validadores, solo es necesario heredar de la clase <code>BaseValidator</code>.</p> Python<pre><code>from cafeto.models import BaseValidator, validate\n\nclass MyValidator(BaseValidator):\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        if value == '??':\n            raise FieldError(Error('name-error', 'Name Error'))\n        return value\n</code></pre> <p>A los validadores tambi\u00e9n se les pueden inyectar dependencias, al igual que a los DTO.</p> Python<pre><code>from cafeto.models import BaseValidator, validate\n\nclass MyValidator(BaseValidator):\n    @validate()\n    async def validate_model(value: Dict[str, Any], some_service: ASomeService) -&gt; Dict[str, Any]:\n        result = await some_service.validate_user(value.get('user'))\n        if not result:\n            raise ModelError([Error('name-error', 'Name Error')])\n        return value\n</code></pre> <p>Para hacer uso del validador, este debe configurarse en la acci\u00f3n del controlador. Esto se realiza en el par\u00e1metro <code>body</code> de los decoradores <code>@app.get</code>, <code>@app.post</code>, <code>@app.put</code>, <code>@app.patch</code> y <code>@app.delete</code>.</p> Python<pre><code>from cafeto.models import BaseModel, BaseValidator, validate\nfrom cafeto.mvc import BaseController\n\nclass MyDto(BaseModel):\n    name: str\n    age: int\n\n\nclass MyValidator(BaseValidator):\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        if value == '??':\n            raise FieldError(Error('name-error', 'Name Error'))\n        return value\n\n\n@app.controller()\nclass MyController(BaseController):\n    @app.post('/create', body={'validator': MyValidator})\n    async def create(self, request: MyDto):\n        # Code\n</code></pre> <p>En este ejemplo, las validaciones propias del DTO, como los campos requeridos (<code>name</code>, <code>age</code>), ser\u00e1n aplicados. Adem\u00e1s, las validaciones personalizadas se ejecutar\u00e1n utilizando el validador <code>MyValidator</code>. Esto es particularmente \u00fatil si se desea mantener un DTO m\u00e1s limpio y reutilizar dichas validaciones entre diferentes DTO.</p> <p>Es posible tener validadores anidados, al igual que los DTO.</p> Python<pre><code>class MyDto(BaseModel):\n    name: str\n\nclass MyComplexDto(BaseModel):\n    complex_name: str\n    my_dto: MyDto\n\nclass MyValidator(BaseValidator):\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        # Validation Code\n\nclass MyComplexValidator(BaseValidator):\n    my_dto: MyValidator\n\n    @validate('complex_name')\n    def validate_complex_name(value: str, _: Dict[str, Any]) -&gt; str:\n        # Validation Code\n</code></pre> <p>No importa si el campo a validar es una lista o un diccionario; la configuraci\u00f3n permanece igual.</p> Python<pre><code>class MyDto(BaseModel):\n    name: str\n\nclass MyComplexDto(BaseModel):\n    complex_name: str\n    my_dto_list: List[MyDto]\n\nclass MyValidator(BaseValidator):\n    @validate('name')\n    def validate_name(value: str, _: Dict[str, Any]) -&gt; str:\n        # Validation Code\n\nclass MyComplexValidator(BaseValidator):\n    my_dto_list: MyValidator\n\n    @validate('complex_name')\n    def validate_complex_name(value: str, _: Dict[str, Any]) -&gt; str:\n        # Validation Code\n</code></pre> <p>Tambi\u00e9n existe la posibilidad de no validar el DTO en absoluto y delegar esta tarea a un proceso manual. Para ello, se debe enviar <code>None</code> en la propiedad <code>body</code> en lugar del validador.</p> Python<pre><code>@app.controller()\nclass MyController(BaseController):\n    @app.post('/create', body={'validator': None})\n    async def create(self, request: MyDto):\n        # Code\n</code></pre> <p>En este caso, el par\u00e1metro <code>request</code> contendr\u00e1 los valores enviados mediante el m\u00e9todo <code>POST</code>, pero sin validaciones.</p> <p>El DTO puede ser validado posteriormente mediante el siguiente c\u00f3digo:</p> Python<pre><code>@app.controller()\nclass MyController(BaseController):\n    @app.post('/create', body={'validator': None})\n    async def create(self, request: MyDto):\n        try:\n            await request.check()\n        except ModelError e:\n            print(e.errors)\n\n        # More Code\n</code></pre> <p>Si se desea usar un validador diferente al DTO, este se debe pasar como par\u00e1metro al m\u00e9todo <code>check</code>.</p> Python<pre><code>try:\n    await request.check(MyValidator)\nexcept ModelError e:\n    print(e.errors)\n</code></pre> <p>Es posible retornar estos errores tal y como los genera la excepci\u00f3n al momento de hacer la validaci\u00f3n del modelo, o formatearlos para que coincidan con el formato que normalmente se utiliza cuando las validaciones se realizan de forma autom\u00e1tica.</p> Python<pre><code>from cafeto.errors import format_errors\nfrom cafeto.responses import BadRequest\n\n@app.controller()\nclass MyController(BaseController):\n    @app.post('/create', body={'validator': None})\n    async def create(self, request: MyDto):\n        try:\n            await request.check()\n        except ModelError e:\n            errors = format_errors(e.errors)\n            return BadRequest(errors)\n\n        # More Code\n</code></pre>"},{"location":"es/websockets/#introduccion","title":"Introducci\u00f3n","text":"<p>Los WebSockets son una tecnolog\u00eda que permite la comunicaci\u00f3n bidireccional en tiempo real entre un cliente (como un navegador web) y un servidor. Esto se realiza a trav\u00e9s de una \u00fanica conexi\u00f3n de socket persistente, lo que reduce la latencia y mejora la eficiencia en aplicaciones que necesitan actualizaciones frecuentes, como chats en vivo, juegos en l\u00ednea o paneles de control en tiempo real.</p> <p>Cafeto utiliza los mismos WebSockets de Starlette para la comunicaci\u00f3n en tiempo real y ofrece dos formas de implementarlo.</p>"},{"location":"es/websockets/#metodo-tradicional","title":"M\u00e9todo tradicional","text":"Python<pre><code>@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        await self.websocket.accept()\n        # Your code on connect here.\n\n        while True:\n            try:\n                # Your code on receive here.\n                data = await self.websocket.receive_json()\n\n                # Send message.\n                await self.websocket.send_json({'Hola': 'Mundo'})\n            except Exception as e:\n                # Your code on disconnect here.\n                break\n</code></pre> <p>En este caso, se recibe la informaci\u00f3n como un JSON sin ser asignado a un DTO y la respuesta es un JSON con el formato:</p> JSON<pre><code>{\n    \"message\": \"Hi\",\n    \"user\": \"System\"\n}\n</code></pre>"},{"location":"es/websockets/#metodo-callback","title":"M\u00e9todo callback","text":"Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        async def on_connect():\n            pass # Your code on connect here.\n\n        async def on_disconnect():\n            pass # Your code on disconnect here.\n\n        async def on_receive(data: ChatRequestDto) -&gt; ChatResponseDto:\n            # Your code on receive here.\n            response = ChatResponseDto(message='Hi', user='System')\n\n            # Response message.\n            return Ok(response)\n\n        await self.websocket.accept_callback(\n            on_connect=on_connect,\n            on_disconnect=on_disconnect,\n            on_receive=on_receive\n        )\n</code></pre> Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import ModelWSResponse\n\n@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        async def on_connect():\n            pass # Your code on connect here.\n\n        async def on_disconnect():\n            pass # Your code on disconnect here.\n\n        async def on_receive(data: ChatRequestDto) -&gt; ChatResponseDto:\n            # Your code on receive here.\n            response = ChatResponseDto(message='Hi', user='System')\n\n            # Response message.\n            return ModelWSResponse(response)\n\n        await self.websocket.accept_callback(\n            on_connect=on_connect,\n            on_disconnect=on_disconnect,\n            on_receive=on_receive\n        )\n</code></pre> <p>Nota: Es importante notar que la respuesta no se debe hacer usando <code>ModelResponse</code> sino <code>ModelWSResponse</code>. Por ahora, las respuestas como JSONResponse, PlainTextResponse y HTMLResponse no est\u00e1n disponibles con WebSockets.</p> <p>Tambi\u00e9n es posible hacerlo as\u00ed:</p> Estilo UnificadoEstilo Cl\u00e1sico Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import Ok\n\n@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        await self.websocket.accept_callback(\n            on_receive=self.on_receive,\n            on_connect=self.on_connect,\n            on_disconnect=self.on_disconnect\n        )\n\n    async def on_connect(self):\n        pass # Your code on connect here.\n\n    async def on_disconnect(self) -&gt; None:\n        pass # Your code on disconnect here.\n\n    async def on_receive(self, data: ChatRequestDto) -&gt; ChatResponseDto:\n        # Your code on receive here.\n        response = ChatResponseDto(message='Hi', user='System')\n\n        # Response message.\n        return Ok(response)\n</code></pre> Python<pre><code>from cafeto.mvc import BaseController\nfrom cafeto.responses import ModelWSResponse\n\n@app.controller()\nclass WsController(BaseController):\n    @app.websocket('/chat')\n    async def chat(self) -&gt; None:\n        await self.websocket.accept_callback(\n            on_receive=self.on_receive,\n            on_connect=self.on_connect,\n            on_disconnect=self.on_disconnect\n        )\n\n    async def on_connect(self):\n        pass # Your code on connect here.\n\n    async def on_disconnect(self) -&gt; None:\n        pass # Your code on disconnect here.\n\n    async def on_receive(self, data: ChatRequestDto) -&gt; ChatResponseDto:\n        # Your code on receive here.\n        response = ChatResponseDto(message='Hi', user='System')\n\n        # Response message.\n        return ModelWSResponse(response)\n</code></pre> <p>En este m\u00e9todo, los mensajes llegan en un DTO, con todas las validaciones y caracter\u00edsticas que los DTO implican en las acciones HTTP.</p> <p>La respuesta tambi\u00e9n cambia, ya que los mensajes por WebSockets no tienen un <code>statusCode</code> como las peticiones HTTP tradicionales. El mensaje que llega tendr\u00eda el siguiente formato:</p> JSON<pre><code>{\n    \"statusCode\": 200,\n    \"body\": {\n        \"message\": \"Hi\",\n        \"user\": \"System\"\n    }\n}\n</code></pre> <p>Pero si las validaciones del DTO fallan, la respuesta podr\u00eda ser:</p> JSON<pre><code>{\n    \"statusCode\": 400,\n    \"body\": {\n        \"errorList\": [\n            {\n                \"loc\": [\"message\"],\n                \"type\": \"missing\",\n                \"msg\": \"Field required\"\n            }\n        ]\n    }\n}\n</code></pre> <p>De esta forma, se puede emular la respuesta de las peticiones HTTP.</p> <p>Nota: Solo el callback <code>on_receive</code> es requerido; <code>on_connect</code> y <code>on_disconnect</code> son opcionales.</p>"},{"location":"es/dto/dto/#introduccion","title":"Introducci\u00f3n","text":"<p>Un DTO (Data Transfer Object) es un patr\u00f3n de dise\u00f1o utilizado en el desarrollo de software para facilitar la transferencia de datos entre diferentes capas o componentes de una aplicaci\u00f3n. Su funcionamiento se centra en tres aspectos clave:</p> <ol> <li> <p>Obtenci\u00f3n de datos desde el request: Los DTOs se encargan de recibir los datos proporcionados por el cliente en solicitudes (requests), encapsul\u00e1ndolos de manera estructurada y clara.</p> </li> <li> <p>Validaci\u00f3n y calidad de los datos: Antes de que los datos se procesen o se almacenen, el DTO garantiza que cumplan con los requisitos de validaci\u00f3n, como tipos de datos correctos, valores esperados, y posibles restricciones. Esto asegura la integridad y calidad de la informaci\u00f3n dentro de la aplicaci\u00f3n.</p> </li> <li> <p>Puente entre cliente y datos internos: Act\u00faan como intermediarios entre las solicitudes del cliente y las capas internas del sistema, como la capa de l\u00f3gica de negocio o la de persistencia. Esto desacopla las estructuras internas del sistema de las interacciones externas, promoviendo un dise\u00f1o m\u00e1s flexible y mantenible.</p> </li> </ol> <p>En resumen, un DTO no solo organiza los datos entrantes, sino que tambi\u00e9n asegura que sean consistentes y cumple con el rol de conectar de manera eficiente al cliente con los procesos internos.</p> <p>Cafeto usa Pydantic como librer\u00eda para la creaci\u00f3n de los DTO.</p>"},{"location":"es/dto/dto/#uso","title":"Uso","text":"Python<pre><code>from datetime import date\n\nfrom cafeto.models import BaseModel\n\n\nclass CreateUserRequestDto(BaseModel):\n    username: str\n    password: str\n    confirm_password: str\n    name: str\n    birth_date: date\n\n\nclass CreateUserResponseDto(BaseModel):\n    id: int\n    username: str\n    name: str\n    birth_date: date\n</code></pre> <p>Aqu\u00ed se definen dos DTO, uno para la entrada de datos (Request) y otro para la salida (Response).</p> <p>Nota: La clase <code>BaseModel</code> viene de <code>cafeto.models</code>, que hereda de <code>BaseModel</code> de Pydantic, ya que se han a\u00f1adido algunas funciones necesarias.</p> <p>Una buena estrategia es utilizar una clase base para compartir los campos relacionados con el <code>request</code> y el <code>response</code>. De esta manera, las clases que hereden de ella podr\u00e1n reutilizar estos campos, evitando la necesidad de definirlos varias veces.</p> Python<pre><code>from datetime import date\n\nfrom cafeto.models import BaseModel\n\n\nclass BaseUserDto(BaseModel):\n    username: str\n    name: str\n    birth_date: date\n\n\nclass CreateUserRequestDto(BaseUserDto):\n    password: str\n    confirm_password: str\n\n\nclass CreateUserResponseDto(BaseUserDto):\n    id: int\n</code></pre> <p>Es posible lograr una configuraci\u00f3n lo suficientemente robusta como para organizar de manera m\u00e1s eficiente los DTOs, garantizando claridad y orden en su estructura.</p> Python<pre><code>from datetime import date\n\nfrom cafeto.models import BaseModel\n\n\nclass BaseUserDto(BaseModel):\n    username: str\n    name: str\n    birth_date: date\n\n\nclass BaseUserRequestDto(BaseUserDto):\n    password: str\n    confirm_password: str\n\n\nclass BaseUserResponseDto(BaseUserDto):\n    id: int\n\n\nclass CreateUserRequestDto(BaseUserRequestDto):\n    ...\n\n\nclass UpdateUserRequestDto(BaseUserRequestDto):\n    old_password: str\n\n\nclass CreateUserResponseDto(BaseUserResponseDto):\n    ...\n\n\nclass UpdateUserResponseDto(BaseUserResponseDto):\n    ...\n</code></pre>"},{"location":"es/dto/generic_response/#introduccion","title":"Introducci\u00f3n","text":"<p>Este DTO se utiliza para enviar respuestas que contienen un valor gen\u00e9rico.</p> Python<pre><code>from cafeto.dtos import GenericResponseDto\n\n@app.controller()\nclass HomeController(BaseController):\n    @app.get('/home')\n    async def home(self) -&gt; GenericResponseDto[str]:\n        # Response Generic str\n        return Ok(GenericResponseDto(data='Hello World!'))\n</code></pre> Python<pre><code>from cafeto.dtos import GenericResponseDto\n\n@app.controller()\nclass HomeController(BaseController):\n    @app.get('/home')\n    async def home(self) -&gt; GenericResponseDto[Dict[str, str]]:\n        # Response Generic Dict\n        return Ok(GenericResponseDto(data={'Hello': 'World!'}))\n</code></pre>"},{"location":"es/other/alternatives/","title":"Alternativas","text":"<p>Cafeto es un framework ligero y poderoso basado en Starlette, dise\u00f1ado para simplificar y acelerar el desarrollo de APIs modernas. Permite crear APIs de forma organizada, integrando soporte para los tres tipos de inyecci\u00f3n de dependencias: Singleton, Scoped y Transient.</p> <p>Adem\u00e1s, Cafeto utiliza DTOs para gestionar, validar y estructurar los datos que se env\u00edan y reciben en el servidor. Tambi\u00e9n incluye integraci\u00f3n con OpenAPI y Swagger, facilitando la documentaci\u00f3n y pruebas de las APIs.</p> <p>Aunque Cafeto es una herramienta robusta, existen otras opciones como Starlette, un framework ligero y de alto rendimiento que sirve como base para otros frameworks como FastAPI y Cafeto. Tambi\u00e9n est\u00e1 FastAPI, conocido por su rapidez y validaci\u00f3n autom\u00e1tica de datos; Django, ideal para aplicaciones a gran escala con su enfoque \"todo en uno\"; y Flask, un microframework flexible para proyectos m\u00e1s sencillos. Cada herramienta tiene su fortaleza, pero Cafeto destaca al combinar eficiencia, estructura y organizaci\u00f3n en un solo paquete.</p>"},{"location":"es/other/coming_soon/","title":"Pr\u00f3ximamente","text":""},{"location":"es/other/coming_soon/#introduccion","title":"Introducci\u00f3n","text":"<p>Aunque el sistema ya es muy efectivo y ofrece un conjunto s\u00f3lido de caracter\u00edsticas, se est\u00e1 trabajando continuamente para mejorarlo. El objetivo es seguir implementando nuevas mejoras y funcionalidades para optimizar la experiencia del usuario. Aqu\u00ed tienes algunas de las emocionantes actualizaciones que se pueden esperar:</p>"},{"location":"es/other/coming_soon/#inyeccion-de-dependencias-desde-el-constructor-del-controlador","title":"Inyecci\u00f3n de dependencias desde el constructor del controlador","text":"<p>Permitir que las acciones que comparten dependencias no necesiten definirlas en cada acci\u00f3n del mismo controlador.</p> <p>Ejemplo:</p> Python<pre><code>@app.controller()\nclass UserController(BaseController):\n    def __init__(self, my_dependency: MyDependency):\n        self.my_dependency = my_dependency\n\n    @app.get('/get')\n    async def get(self) -&gt; UserResponseDto:\n        await self.my_dependency.do_something()\n\n    @app.get('/get-all')\n    async def get_all(self) -&gt; UserResponseDto:\n        await self.my_dependency.do_something()\n</code></pre>"},{"location":"es/other/coming_soon/#mejoras-en-la-funcionalidad-de-los-eventos","title":"Mejoras en la funcionalidad de los eventos","text":"<p>Optimizar el sistema de eventos para hacerlo m\u00e1s vers\u00e1til y robusto, incorporando caracter\u00edsticas como:</p> <ul> <li> <p>Permitir que los eventos generen respuestas, facilitando una interacci\u00f3n m\u00e1s din\u00e1mica.</p> </li> <li> <p>Implementar la capacidad de lanzar excepciones desde los eventos, con soporte para que estas puedan ser capturadas e interceptadas seg\u00fan sea necesario.</p> </li> <li> <p>Asegurar un manejo eficiente de errores y un flujo controlado en la ejecuci\u00f3n de los eventos.</p> </li> </ul>"},{"location":"es/other/coming_soon/#incorporacion-de-nuevos-eventos","title":"Incorporaci\u00f3n de nuevos eventos","text":"<p>Extender el sistema actual con la adici\u00f3n de nuevos eventos. Algunas ideas iniciales incluyen:</p> <ul> <li>OnModeValidationFail: Evento desencadenado cuando la validaci\u00f3n de un modo falla, permitiendo gestionar este caso de manera espec\u00edfica y personalizada.</li> </ul>"},{"location":"es/other/coming_soon/#sistema-mejorado-de-validaciones","title":"Sistema mejorado de validaciones","text":"<p>Implementaremos un sistema m\u00e1s avanzado para la validaci\u00f3n de datos.</p> <p>La idea general es crear un sistema de validaciones que se pueda usar fuera de los DTOs y ofrecer una forma f\u00e1cil de retornar errores en caso de existir.</p>"},{"location":"es/other/coming_soon/#objetivos","title":"Objetivos","text":"<ul> <li>Flexibilidad: Permitir el uso de validaciones en diferentes contextos m\u00e1s all\u00e1 de los DTOs.</li> <li>Facilidad de uso: Proveer una interfaz sencilla para la definici\u00f3n y el manejo de reglas de validaci\u00f3n.</li> <li>Eficiencia: Garantizar que las validaciones se realicen de manera r\u00e1pida y efectiva.</li> </ul>"},{"location":"es/other/coming_soon/#implementacion-de-cli","title":"Implementaci\u00f3n de CLI","text":"<p>Desarrollaremos una interfaz de l\u00ednea de comandos (CLI) para la creaci\u00f3n de proyectos.</p>"},{"location":"es/other/coming_soon/#ejemplos","title":"Ejemplos","text":"<ol> <li> <p>Crear un nuevo proyecto: Bash<pre><code>cafeto new project-name\n</code></pre></p> </li> <li> <p>Generar un controlador: Bash<pre><code>cafeto create controller user\n</code></pre></p> </li> </ol>"},{"location":"es/other/coming_soon/#objetivos_1","title":"Objetivos","text":"<ul> <li> <p>Facilidad de uso: Proveer comandos sencillos e intuitivos para la creaci\u00f3n y gesti\u00f3n de proyectos.</p> </li> <li> <p>Eficiencia: Reducir el tiempo y esfuerzo necesarios para inicializar y configurar proyectos.</p> </li> <li> <p>Flexibilidad: Permitir la extensi\u00f3n y personalizaci\u00f3n de la CLI seg\u00fan las necesidades del usuario.</p> </li> </ul>"},{"location":"es/other/coming_soon/#plantillas-de-desarrollo","title":"Plantillas de desarrollo","text":"<p>Dotaremos al sistema con la capacidad de iniciar proyectos con plantillas predefinidas, evitando comenzar desde cero en cada nuevo proyecto.</p>"},{"location":"es/other/coming_soon/#sistema-de-usuarios-y-permisos-por-defecto","title":"Sistema de usuarios y permisos por defecto","text":"<p>Desarrollaremos un sistema en el cual la gesti\u00f3n de usuarios y permisos estar\u00e1 predise\u00f1ada, permitiendo ahorrar tiempo en cada nuevo proyecto.</p>"},{"location":"es/other/coming_soon/#mejoras-en-la-documentacion","title":"Mejoras en la documentaci\u00f3n","text":"<p>Estamos trabajando en mejorar la documentaci\u00f3n, a\u00f1adiendo m\u00e1s ejemplos y proporcionando m\u00e1s detalles sobre las caracter\u00edsticas del sistema.</p>"},{"location":"es/other/coming_soon/#incrementar-el-soporte-a-los-parametros","title":"Incrementar el soporte a los par\u00e1metros","text":"<p>A\u00f1adir la capacidad de soportar otros tipos de datos m\u00e1s complejos como listas, fechas, etc.</p> Python<pre><code>from datetime import date\nfrom typing import List\n\nfrom cafeto.mvc import BaseController\n\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/view-filter/{ids}', query=['date'])\n    async def view_filter(self, ids: List[int], date: date) -&gt; None:\n        pass\n</code></pre>"},{"location":"es/other/coming_soon/#mejorar-la-integracion-con-openapi","title":"Mejorar la integraci\u00f3n con OpenApi","text":"<p>Daremos m\u00e1s soporte a las caracter\u00edsticas de OpenApi para mejorar la integraci\u00f3n.</p>"},{"location":"es/other/coming_soon/#integracion-con-prometheus-y-grafana","title":"Integraci\u00f3n con Prometheus y Grafana","text":"<p>Con el sistema de plantillas y usando Docker, se implementar\u00e1 la capacidad de crear logs de los eventos del API para generar m\u00e9tricas del sistema. Esta integraci\u00f3n permitir\u00e1 a los desarrolladores y administradores de sistemas monitorear el rendimiento y la salud de sus aplicaciones de manera m\u00e1s efectiva.</p>"},{"location":"es/other/coming_soon/#objetivos_2","title":"Objetivos","text":"<ul> <li>Monitoreo en tiempo real: Permitir la observaci\u00f3n en tiempo real de las m\u00e9tricas del sistema, como el uso de CPU, memoria, latencia de las solicitudes, tasas de error, entre otros.</li> <li>Alertas proactivas: Configurar alertas que notifiquen a los administradores cuando ciertos umbrales cr\u00edticos sean alcanzados, permitiendo una respuesta r\u00e1pida a posibles problemas.</li> <li>An\u00e1lisis hist\u00f3rico: Almacenar datos hist\u00f3ricos para analizar tendencias y patrones de uso a lo largo del tiempo, ayudando en la toma de decisiones informadas sobre la infraestructura y el rendimiento de la aplicaci\u00f3n.</li> <li>Visualizaci\u00f3n de datos: Utilizar Grafana para crear dashboards personalizados que visualicen las m\u00e9tricas recolectadas de manera clara y comprensible.</li> </ul>"},{"location":"es/other/coming_soon/#respuestas-en-estilos-personalizados","title":"Respuestas en estilos personalizados","text":"<p>Permitir elegir entre diferentes estilos de respuesta para los servicios, no limit\u00e1ndose \u00fanicamente a JSON. La idea es poder cambiar entre <code>JSON</code>, <code>XML</code> y <code>YML</code>.</p> Estilo unificadoEstilo clasico Python<pre><code>from cafeto.responses import Ok\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/view/{id}')\n    async def view(self, id: int) -&gt; UserResponseDto:\n        user = &lt;some_user_service&gt;.get(id)\n        return Ok(UserResponseDto(**user), style='XML')\n</code></pre> Python<pre><code>from cafeto.responses import ModelResponse\n\n@app.controller()\nclass UserController(BaseController):\n    @app.get('/view/{id}')\n    async def view(self, id: int) -&gt; UserResponseDto:\n        user = &lt;some_user_service&gt;.get(id)\n        return ModelResponse(UserResponseDto(**user), style='XML')\n</code></pre> <p>Info</p> <p>estilos</p> <ul> <li>style='JSON' (default)</li> <li>style='XML'</li> <li>style='YML'</li> </ul>"},{"location":"es/other/coming_soon/#mejoras-de-rendimiento","title":"Mejoras de rendimiento","text":"<p>Optimizaremos el sistema para asegurar un rendimiento m\u00e1s r\u00e1pido y eficiente.</p>"},{"location":"es/other/coming_soon/#creacion-de-un-prefijo-para-el-api","title":"Creaci\u00f3n de un prefijo para el API","text":"<p>Se propone la funcionalidad de agregar un prefijo a las URLs de todos los endpoints de la API para mantener una estructura m\u00e1s organizada y consistente.</p> <p>Por ejemplo, utilizando el siguiente comando:</p> Python<pre><code>app.map_controllers(prefix='my-api')\n</code></pre> <p>Esto garantizar\u00e1 que todas las rutas de los servicios comiencen con el prefijo especificado. El resultado ser\u00eda algo como:</p> Bash<pre><code>http://127.0.0.1:8000/my-api/my-controller/my-action\n</code></pre> <p>De esta forma, se facilita la agrupaci\u00f3n de endpoints bajo un mismo contexto y se mejora la legibilidad y administraci\u00f3n de las rutas dentro de la API.</p>"},{"location":"es/other/coming_soon/#sistema-de-versionamiento-de-las-apis","title":"Sistema de versionamiento de las APIs","text":"<p>Implementar un sistema de versionamiento para las APIs que permitir\u00e1 a los desarrolladores gestionar y mantener m\u00faltiples versiones de sus APIs de manera eficiente.</p>"},{"location":"es/other/coming_soon/#objetivos_3","title":"Objetivos","text":"<ul> <li>Compatibilidad: Asegurar que las versiones anteriores de las APIs sigan funcionando mientras se desarrollan nuevas versiones.</li> <li>Facilidad de uso: Proveer herramientas y documentaci\u00f3n clara para la gesti\u00f3n de versiones.</li> <li>Flexibilidad: Permitir a los desarrolladores elegir qu\u00e9 versiones de las APIs desean mantener y cu\u00e1les descontinuar.</li> </ul>"},{"location":"es/other/coming_soon/#ejemplo","title":"Ejemplo","text":"Python<pre><code># --- main.py ---\napp.map_controllers(version='v2')\n\n# --- user_v1.py ---\n@app.controller(version='v1')\nclass UserController(BaseController):\n    @app.get('/user')\n    async def get_user(self) -&gt; UserResponseDto:\n        pass\n\n# --- user_v2.py ---\n@app.controller(version='v2') #(1)\nclass UserController(BaseController):\n    @app.get('/user')\n    async def get_user(self) -&gt; UserResponseDto:\n        pass\n</code></pre> <ol> <li> <p>Info</p> Otra manera Python<pre><code>@app.controller() # 'v2' by default\n</code></pre> </li> </ol>"},{"location":"es/other/coming_soon/#adaptabilidad-y-evolucion-continua","title":"Adaptabilidad y evoluci\u00f3n continua","text":"<p>Nos comprometemos con la mejora continua y la adaptaci\u00f3n a las novedades del entorno tecnol\u00f3gico. El proyecto est\u00e1 en constante evoluci\u00f3n, observando las tendencias y avances en el \u00e1mbito del desarrollo de software para implementar las mejores pr\u00e1cticas y tecnolog\u00edas m\u00e1s recientes.</p> <p>La meta es asegurarse de que el sistema permanezca actualizado y relevante, incorporando nuevas caracter\u00edsticas y optimizaciones que beneficien a los usuarios. Se agradecen las sugerencias y siempre estamos abiertos a recibir feedback para seguir mejorando.</p>"},{"location":"es/other/coming_soon/#ejemplo_1","title":"Ejemplo","text":"<ul> <li>Integraci\u00f3n de nuevas tecnolog\u00edas: Adoptar nuevas herramientas y frameworks que emergen en el mercado.</li> <li>Actualizaciones regulares: Implementar mejoras y parches de seguridad de manera continua.</li> <li>Feedback del usuario: Escuchar activamente las necesidades y sugerencias de los usuarios para adaptarse a sus requerimientos.</li> </ul>"},{"location":"es/other/license/","title":"Licencia","text":"<p>MIT License</p> <p>Copyright \u00a9 [2025] [Jonathan Espinal]</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"es/services/context/#introduccion","title":"Introducci\u00f3n","text":"<p>Es un servicio de tipo <code>scoped</code> que puede ser inyectado para obtener informaci\u00f3n del contexto de la solicitud actual. La informaci\u00f3n que contiene este servicio es:</p> <ul> <li><code>path: str</code>: Ruta a la cual se lleg\u00f3 a la acci\u00f3n.</li> <li><code>method: str</code>: M\u00e9todo actual (<code>POST</code>, <code>GET</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>).</li> <li><code>headers: Dict[str, Any]</code>: Las cabeceras de la solicitud.</li> <li><code>query: Dict[str, Any]</code>: Los par\u00e1metros del query string.</li> <li><code>controller_name: str</code>: Nombre del controlador al cual lleg\u00f3 la solicitud.</li> <li><code>action_name: str</code>: Nombre de la acci\u00f3n a la cual lleg\u00f3 la solicitud.</li> <li><code>request_model: BaseModel</code>: El DTO con el cuerpo de la solicitud, solo aplica a los m\u00e9todos (<code>POST</code>, <code>PUT</code>, <code>PATCH</code>).</li> </ul> <p>Para usarlo, solo se debe inyectar como cualquier otro servicio.</p> Python<pre><code>from cafeto.services import AContextService\n\nclass MyService:\n    def __init__(self, context_service: AContextService) -&gt; None:\n        self.context_service = context_service\n</code></pre>"},{"location":"es/services/default_services/","title":"Servicios por defecto","text":""},{"location":"es/services/default_services/#introduccion","title":"Introducci\u00f3n","text":"<p>Cafeto cuenta con algunos servicios ya dise\u00f1ados para ser usados mediante inyecci\u00f3n de dependencias.</p> <p>Para usar estos servicios es necesario invocarlos.</p> Python<pre><code>from cafeto import App\n\napp: App = App()\napp.use_default_services()\n</code></pre>"}]}